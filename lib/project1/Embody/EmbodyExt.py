"""
Embody automatically creates, maintains and updates
tox and DAT file externalizations for your project,
supporting a variety of file formats.

Simply add your preferred tags for COMPs/DATs to be saved,
and on ctrl-s external file references will automatically 
be created and/or updated.
"""
import os
import subprocess
import sys
import re
from datetime import datetime, timedelta
import time
import shutil
import TDFunctions as TDF
from pathlib import Path
import random
import string

class EmbodyExt:

    def __init__(self, ownerComp):
        # definitions
        self.my = ownerComp
        self.lister = self.my.op('list/treeLister')
        self.tagging_menu_window = self.my.op('window_tagging_menu')
        self.tagger = self.my.op('tagger')
        self.root = op('/')
        self.divider = '- - -'
        self.complete = '<===========================================>\n'
        self.header = f'Embody >'
        self.supported_dat_oper_types = ['text', 'table', 'execute', 'parexec', 'pargroupexec', 'chopexec', 'datexec', 'opexec', 'panelexec']

        # Mapping of DAT types to default tags
        self.dat_type_to_tag = {
            'text': 'Txttag',
            'table': 'Tsvtag',
            'execute': 'Pytag',
            'parexec': 'Pytag',
            'pargroupexec': 'Pytag',
            'chopexec': 'Pytag',
            'datexec': 'Pytag',
            'opexec': 'Pytag',
            'panelexec': 'Pytag'
        }

        # Mapping of file extensions to tags for TextDATs
        self.extension_language_to_tag = {
            'csv': 'Csvtag',
            'dat': 'Dattag',
            'frag': 'Glsltag',
            'glsl': 'Glsltag',
            'html': 'Htmltag',
            'json': 'Jsontag',
            'md': 'Mdtag',
            'py': 'Pytag',
            'rtf': 'Rtftag',
            'tsv': 'Tsvtag',
            'txt': 'Txttag',
            'vert': 'Glsltag',
            'xml': 'Xmltag',
            'yml': 'Jsontag',
            'python': 'Pytag',
            'yaml': 'Jsontag',
            'xml': 'Xmltag',
            'tscript': 'Pytag',
            'text': 'Txttag'
        }

        # Initialize logging settings
        self._log_levels = {
            'INFO': 0,
            'WARNING': 1,
            'ERROR': 2,
            'SUCCESS': 3
        }

        # properties
        self.param_tracker = ParameterTracker(self.my)

    @property
    def Externalizations(self):
        return self.my.par.Externalizations.eval()

    @property
    def ExternalizationsFolder(self):
        # Return the project folder
        # Return empty string for relative directory paths
        folder = self.my.par.Folder.eval()
        if folder:
            return folder
        else:
           return ''

    ''' INIT '''

    def Reset(self, removeTags=False):
        # Reset (as this is a new instance of Embody)
        parent.Embody.Disable(False, removeTags)
        run(f"op('{self.my}').UpdateHandler()", delayFrames = 10)

        # Generate the externalizations tableDAT
        self.createExternalizationsTable()

        # Clear externaltox path (auto generated by Derivative when adding a component to a network)
        self.my.par.externaltox = ''


    def createExternalizationsTable(self):  
        # Create a tableDAT for externalizations 
        # Name of the externalizations tableDAT
        table_name = 'externalizations'

        # Check if the tableDAT exists
        externalizations_dat = self.Externalizations
        if not externalizations_dat:
            # Create the tableDAT
            externalizations_dat = self.my.parent().create(tableDAT, table_name)
            # Position it next to Embody COMP
            externalizations_dat.nodeX = self.my.nodeX - 200
            externalizations_dat.nodeY = self.my.nodeY
            # Dock the tableDAT to the Embody COMP
            externalizations_dat.dock = self.my
            externalizations_dat.color = (self.my.par.Dattagcolorr, self.my.par.Dattagcolorg, self.my.par.Dattagcolorb)

            # Set the headers
            externalizations_dat.clear()
            externalizations_dat.appendRow(['path', 'type', 'rel_file_path', 'timestamp', 'dirty', 'build', 'touch_build'])

            # add tableDAT tag
            externalizations_dat.tags = [self.my.par.Tsvtag.eval()]

            self.log(f"Created and docked '{table_name}' tableDAT", "SUCCESS")
        else:
            # If it exists, clear it
            externalizations_dat.clear(keepFirstRow=True)
            self.log(f"Reset '{table_name}' tableDAT", "INFO")
        
        # Assign created tableDAT to the 'Externalizations' parameter
        self.my.par.Externalizations.val = externalizations_dat


    def Verify(self):
        # Check if Embody already exists in the project
        embodies = op('/').findChildren(name='Embody', parName='Addtagshort')
        this_embody = self.my
        already_here = 0
        for embody in embodies:
            if embody != this_embody:
                already_here = embody
        if already_here != 0:
            ui.messageBox('Embody', f'An instance of Embody has already been detected in this project.\nPlease remove the existing instance first:\n{already_here}', buttons=['Ok'])
        # If it doesn't exist, prompt user if they want to reset
        do_reset = ui.messageBox('Embody', 'It looks like this is a new instance of Embody.\nWould you like to reset (initialize) it from the previously saved state?\n(If unsure, go with, "Yes").', buttons=['No', 'Yes'])
        if do_reset:
            self.Reset()


    ''' DISABLE '''

    def Disable(self, prevFolder=False, removeTags=False):
        '''
        Clear external tox/DAT file paths on all ops that have them and
        delete all externalized files (tox/DAT) from the Embody folder.
        Delete tags as well if removeTags input is True
        '''
        folder = self.ExternalizationsFolder if prevFolder == None else prevFolder
        if prevFolder == '':
            folder = project.folder

        tags = self.getTags()
        for oper in self.getExternalizedOps(COMP):
            oper.par.externaltox = ''
            self.deleteFile(oper, folder)
            if removeTags:
                removal = [oper.tags.remove(old_tag) for old_tag in tags if old_tag in oper.tags]
                self.resetOpColor(oper)

        for oper in self.getExternalizedOps(DAT):
            try:
                oper.par.syncfile = False
                oper.par.file = ''
            except Exception as e:
                pass
        
            self.deleteFile(oper, folder)

            if removeTags:
                if str(self.Externalizations) not in oper.path:
                    removal = [oper.tags.remove(old_tag) for old_tag in tags if old_tag in oper.tags]
                    self.resetOpColor(oper)

        # Find all top-level COMP operators
        top_level_comps = self.root.findChildren(depth=1, type=COMP)

        # Iterate over these COMPs and attempt to remove their corresponding directories
        for comp in top_level_comps:
            if comp.name not in ['local', 'perform']:
                comp_path = Path(f'{folder}/{comp.name}')
                if comp_path.is_dir() and not any(comp_path.iterdir()):  # Check if directory is empty
                    try:
                        comp_path.rmdir()
                    except Exception as e:
                        self.log(f"Error removing directory: {comp_path}", "ERROR", str(e))

        # After attempting to delete subdirectories, check if the externalizations folder itself is now empty and remove it if it is
        try:
            if folder:
                Path(folder).rmdir()
                self.log(f"Removed directory {folder}", "INFO")
        except Exception as e:
            #self.log(f"Error removing directory [{self.ExternalizationsFolder}]: {e}", "ERROR", "{e}")
            pass

        # Attempt to delete old externalization folder (if changed from current project folder)
        if prevFolder and prevFolder != self.getProjectFolder():
            prev_folder_path = Path(prevFolder)
            if prev_folder_path.is_dir() and prev_folder_path != Path(self.getProjectFolder()):
                try:
                    shutil.rmtree(prev_folder_path, ignore_errors=True)
                    self.log(f"Removed old externalization folder {prev_folder_path}", "INFO")
                except Exception as e:
                    self.log(f"Error removing directory: {prev_folder_path}", "ERROR", str(e))

        else: # Using project folder
            pass

        # Clear and delete table if it exists
        if self.Externalizations:
            run(f"op('{self.Externalizations}').clear(keepFirstRow=True)", delayFrames = 10)

            def delayedDelete():
                self.deleteFile(self.Externalizations, folder)
            
            # Use run() to schedule the deletion after the table is cleared
            run(delayedDelete, delayFrames=11)

        # Set status to false for save out so 
        # Files are not automatically externalized again until re-init
        self.my.par.Status = 'Disabled'

        # Update init button label in manager to 'initialize' as that is the next step
        self.updateEnableButtonLabel('Enable')

        # Delete empty directories in project folder
        def deleteEmpties():
            if folder:
                self.deleteEmptyDirectories(folder)

        run(deleteEmpties, delayFrames = 60)

        self.log("Disabled", "SUCCESS")


    def DisableHandler(self):
        # Prompt user if they want to reset Embody, before resetting
        choice = ui.messageBox('Embody Warning', 'Are you sure you want to disable Embody?\nAll externalized files will be deleted and tox/DAT file parameters cleared.', buttons=['No', 'Yes, keep all Embody Tags', 'Yes, remove all Embody Tags'])
        if choice:
            self.Disable(self.ExternalizationsFolder, choice - 1)


    ''' GET OPS '''

    def getOpPaths(self, opToExternalize, externalizationsFolder):
        if externalizationsFolder == False:
            externalizationsFolder = self.ExternalizationsFolder

        # For COMPs/DATs with custom external path, respect that first
        if opToExternalize.family == 'COMP' and opToExternalize.par.externaltox.eval():
            # Normalize the path to use forward slashes
            rel_file_path = str(Path(opToExternalize.par.externaltox.eval()))
            abs_folder_path = Path(project.folder) / Path(rel_file_path).parent
            save_file_path = Path(project.folder) / rel_file_path
            rel_directory = Path(rel_file_path).parent
            return abs_folder_path, save_file_path, rel_directory, rel_file_path
        elif opToExternalize.family == 'DAT' and opToExternalize.par.file.eval():
            # Normalize the path to use forward slashes
            rel_file_path = str(Path(opToExternalize.par.file.eval()))
            abs_folder_path = Path(project.folder) / Path(rel_file_path).parent
            save_file_path = Path(project.folder) / rel_file_path
            rel_directory = Path(rel_file_path).parent
            return abs_folder_path, save_file_path, rel_directory, rel_file_path

        # Otherwise continue with standard path generation...
        if opToExternalize.family == 'COMP':
            file_extension = '.tox'
        elif opToExternalize.family == 'DAT':
            tags = self.getTags()
            found = [tag for tag in opToExternalize.tags if tag in tags]
            file_extension = f'.{found[0]}' if found else None

        if file_extension is not None:
            # Use the current operator name for the filename
            filename = opToExternalize.name + file_extension
            
            # Get the parent path components
            parent_path = str(opToExternalize.parent().path).strip('/')
            parent_components = parent_path.split('/')
            
            # Build paths
            rel_directory = Path(externalizationsFolder, *parent_components)
            rel_file_path = str(rel_directory / filename)
            abs_folder_path = rel_directory.resolve()
            
            # Convert Path to string with forward slashes for rel_file_path
            return abs_folder_path, Path(project.folder) / rel_file_path, rel_directory, rel_file_path
        else:
            self.log("File extension not found", "ERROR")
            return None, None, None, None


    def isOpEligibleToBeExternalized(self, opToTest):
        """
        Determine if an operator can be externalized.
        For COMPs, always allow externalization.
        For DATs, check if they're properly tagged and of supported type.
        """
        if opToTest.family == 'COMP':
            return True
        else:
            # For DATs, first check if it's a supported type
            if opToTest.type not in self.supported_dat_oper_types:
                return False
                
            # Check if it has any of our supported tags
            dat_tags = self.getTags('DAT')
            has_supported_tag = any(tag in opToTest.tags for tag in dat_tags)
            
            if not has_supported_tag:
                return False
                
            # Now check file status - allow externalization if:
            # 1. File parameter is empty
            # 2. Has a sync file warning
            # 3. Has one of our tags and an existing file path (for existing projects)
            # 4. Already has a custom file path set (new condition)
            return (opToTest.par.file.eval() == '' or 
                    "File not found for sync" in opToTest.warnings() or
                    (has_supported_tag and opToTest.par.file.eval()) or
                    opToTest.par.file.eval() != '')


    def getExternalizedOps(self, opFamily):
        externalized_ops = []
        
        # If table doesn't exist yet, return empty list
        if not self.Externalizations:
            return externalized_ops
            
        # Convert opFamily to string for comparison
        family_str = 'COMP' if opFamily == COMP else 'DAT'
        
        for i in range(1, self.Externalizations.numRows):
            path = self.Externalizations[i, 'path'].val
            oper = op(path)
            if oper and oper.family == family_str:
                if not oper.path.startswith('/local/') and oper.path != '/local':
                    externalized_ops.append(oper)

        return sorted(externalized_ops, key=lambda x: -x.path.count('/'))


    ''' SAVE '''

    def Save(self, opPath):
        # Save the external tox file for COMPs and record the timestamp
        try:
            oper = op(opPath)
            oper.par.enableexternaltox = True
            oper.saveExternalTox()

            # Update build number, date and touch build
            if hasattr(oper.par, 'Build'):
                oper.par.Build.val += 1
                self.Externalizations[opPath, 'build'] = str(oper.par.Build.val)
                
            if hasattr(oper.par, 'Date'):
                oper.par.Date.val = datetime.utcnow().strftime("%Y-%m-%d %H:%M:%S UTC")
                
            if hasattr(oper.par, 'Touchbuild'):
                oper.par.Touchbuild.val = app.build
                self.Externalizations[opPath, 'touch_build'] = app.build

            # Check if there's an attribute for external timestamp and use it
            if hasattr(oper.par, 'externalTimeStamp') and oper.externalTimeStamp != 0:
                # Assuming externalTimeStamp is in a format that needs conversion to standard timestamp
                utc_time = datetime.utcfromtimestamp(oper.externalTimeStamp / 10000000 - 11644473600)
                timestamp = utc_time.strftime("%Y-%m-%d %H:%M:%S UTC")
            else:
                # Fallback to the current UTC time if no external timestamp is available
                timestamp = datetime.utcnow().strftime("%Y-%m-%d %H:%M:%S UTC")

            self.Externalizations[opPath, 'timestamp'] = timestamp

            # After successful save, update parameter tracker state
            self.param_tracker.updateParamStore(oper)
            
            # Clear the dirty flag in the table
            self.Externalizations[opPath, 'dirty'] = False

            self.log(f"Saved {opPath}", "SUCCESS")
        except Exception as e:
            self.log("Save operation failed", "ERROR", str(e))

        self.Refresh()


    def dirtyHandler(self, update):
        # Save and record whether COMPs has been edited
        updates = []
        for oper in self.getExternalizedOps(COMP):
            dirty = oper.dirty
            try:
                self.Externalizations[oper.path, 'dirty'] = dirty
            except:
                #print(f"{self.header} error: The TOX tag for ['{oper.path}'] was added after its external tox parameter was initalized, or the COMP was renamed. Please delete its external tox parameter so it can be properly re-initialized by Embody.")
                pass

            # Update tox if it's source COMP has been edited
            if dirty and update:
                self.Save(oper.path)

        return updates


    def getOpsByTag(self, opFamily):
        # Return OPs by tag
        tags = self.getTags('tox') if opFamily == COMP else self.getTags('DAT')
        return self.root.findChildren(type=opFamily, tags=tags)


    def getOpsByPar(self, opFamily):
        # Return OPs by parameter
        if opFamily == COMP:
            ops_by_par = self.root.findChildren(type=opFamily, 
                key=lambda x: x.par.externaltox.eval() != '' 
                    and x.type != 'engine'
                    and x.type != 'time'
                    and x.type != 'annotate')
        else:
            ops_by_par = self.root.findChildren(type=opFamily, 
                parName='file', 
                key=lambda x: x.par.file.eval() != '', 
                path='^/local/shortcuts')  
        return ops_by_par


    def getOpsToExternalize(self, opFamily):
        # Get all ops marked for externalization (with tags on COMP/DAT op types)
        if opFamily == COMP:
            ops_to_externalize = self.root.findChildren(
                type=opFamily,
                tags=self.getTags('tox'),
                parName='externaltox',
                key=lambda x: self.isOpEligibleToBeExternalized(x) and not x.path.startswith('/local/') and x.path != '/local' and x.type != 'engine'
            )
        elif opFamily == DAT:
            ops_to_externalize = self.root.findChildren(
                type=opFamily,
                tags=self.getTags('DAT'),
                parName='file',
                key=lambda x: self.isOpEligibleToBeExternalized(x) and not x.path.startswith('/local/') and x.path != '/local'
            )
        else:
            ops_to_externalize = []
        return ops_to_externalize


    def updateEnableButtonLabel(self, label):
        '''
        Update button label so it only displays 
        'Initialize' for the first init, and then
        'Update' for further updates while running
        '''
        init_button = self.my.op('toolbar/container_left/initialize')
        init_button.par.Buttonofflabel = label
        init_button.par.Buttononlabel = label


    ''' REFRESH '''

    def Refresh(self):
        # Clean up duplicates first
        self.cleanupAllDuplicateRows()

        # Refresh Embody (update dirty state, Lister UI, check for any OP migrations or duplicates)
        self.updateDirtyStates(self.ExternalizationsFolder)
        self.lister.par.Refresh.pulse()
        self.checkOpsForContinuity(self.ExternalizationsFolder)
        if self.my.par.Detectduplicatepaths:
            self.checkForDuplicates()
        self.log("Refreshed", "INFO")

        # Check if timeline is paused
        if not me.time.play:
            self.log(f"- - -\n\n\n{self.header} ALERT! ALERT! YOUR TIMELINE IS PAUSED. RESUME PLAYBACK FOR EMBODY TO FUNCTION\n\n\n- - -", "ERROR")


    def updateDirtyStates(self, externalizationsFolder):
        """Updated method to check both traditional dirty states and parameter changes"""
        # Check which COMPs are dirty through traditional means
        dirties = self.dirtyHandler(False)
        param_changes = []

        # Check for externaltox/file path changes and parameter changes
        for oper in self.getExternalizedOps(COMP) + self.getExternalizedOps(DAT):
            # Update path in table if it changed
            current_path = oper.par.externaltox.eval() if oper.family == 'COMP' else oper.par.file.eval()
            try:
                table_path = self.Externalizations[oper.path, 'rel_file_path']
                if current_path != table_path:
                    self.Externalizations[oper.path, 'rel_file_path'] = current_path
                    # Make parameter readOnly
                    if oper.family == 'COMP':
                        oper.par.externaltox.readOnly = True
                    else:  # DAT
                        oper.par.file.readOnly = True
                    self.log(f"Updated externalization path for {oper.path} to {current_path}", "SUCCESS")
            except:
                pass
            
            # Check for parameter changes in COMPs
            if oper.family == 'COMP':
                if self.param_tracker.compareParameters(oper):
                    param_changes.append(oper.path)
                    # Mark as dirty in externalizations table
                    self.Externalizations[oper.path, 'dirty'] = 'Par'
                    # Update stored parameters after marking dirty
                    #self.param_tracker.updateParamStore(oper)

        # Log findings
        if dirties or param_changes:
            messages = []
            if dirties:
                plurality = "an" if len(dirties) == 1 else "es"
                messages.append(f"{len(dirties)} unsaved tox{plurality}")
            if param_changes:
                plurality = "" if len(param_changes) == 1 else "s"
                messages.append(f"{len(param_changes)} COMP{plurality} with parameter changes")
                
            self.log(f"Found {' and '.join(messages)}", "INFO")

    def checkExternalToxPar(self):
        # First check all COMPs for fileFolder pattern in externaltox
        comps_with_filefolder = self.root.findChildren(type=COMP, key=lambda x: (
            x.par.externaltox.expr and 
            "me.parent().fileFolder + '/' +" in x.par.externaltox.expr
        ))
        
        if comps_with_filefolder:
            message = ("Found COMPs with externaltox paths using 'me.parent().fileFolder':\n\n" + 
                      "\n".join([f"- {comp.path}" for comp in comps_with_filefolder]) + 
                      "\n\nWould you like to reset these externaltox paths?")
            choice = ui.messageBox('Embody', message, buttons=['No', 'Yes'])
            
            if choice == 1:  # User clicked Yes
                for comp in comps_with_filefolder:
                    try:
                        comp.par.externaltox.expr = ''
                        comp.par.externaltox = ''
                        self.log(f"Reset externaltox path for '{comp.path}'", "SUCCESS")
                    except Exception as e:
                        self.log(f"Error resetting externaltox for '{comp.path}'", "ERROR", str(e))

    def checkOpsForContinuity(self, externalizationsFolder):
        """
        Checks for renamed or missing operators and updates the externalizations table accordingly.
        Prevents row deletion during rename operations.
        """
        self.checkExternalToxPar()
        try:
            # Store all rows that need checking
            rows_to_check = []
            for i in range(1, self.Externalizations.numRows):
                row_path = self.Externalizations[i, 'path'].val
                if not row_path:
                    continue
                rel_file_path = self.Externalizations[i, 'rel_file_path'].val
                rows_to_check.append((row_path, rel_file_path))

            # Track renamed operators to prevent duplicate processing
            processed_ops = set()

            # Process each row
            for old_op_path, rel_file_path in rows_to_check:
                if old_op_path in processed_ops:
                    continue

                existing_op = op(old_op_path)
                
                if existing_op:
                    # Operator still exists, just update timestamps
                    self.updateOpTimestamp(existing_op, externalizationsFolder)
                else:
                    # Check all operators for matching file path before declaring missing
                    found_renamed = False
                    for potential_op in self.root.findChildren(type=COMP):
                        if (potential_op.par.externaltox and 
                            potential_op.par.externaltox.eval() == rel_file_path and
                            potential_op.path != old_op_path):
                            # Found the renamed operator
                            self.updateRenamedOp(potential_op, old_op_path, rel_file_path, externalizationsFolder)
                            processed_ops.add(potential_op.path)
                            found_renamed = True
                            break
                    
                    if not found_renamed:
                        # Only remove if truly missing (not renamed)
                        self.handleMissingOperator(old_op_path, rel_file_path, externalizationsFolder)

        except Exception as e:
            self.log(f"Error in checkOpsForContinuity", "ERROR", str(e))


    def get_local_time_from_utc(self, utc_time):
        # Return local time
        local_now = datetime.now()
        utc_now = datetime.utcnow()
        offset = local_now - utc_now
        local_time = utc_time + offset
        return local_time


    def updateOpTimestamp(self, oper, externalizationsFolder):
        # Update the timestamp in the externalizations tableDAT for a specific OP
        if oper.family == 'COMP':
            save_file_path = self.getOpPaths(oper, self.ExternalizationsFolder)[1]
            # Retrieve the last modified time as UTC directly from the file system
            last_modified = int(Path(save_file_path).stat().st_mtime)
            last_modified_utc = datetime.utcfromtimestamp(last_modified)
            formatted_time = last_modified_utc.strftime("%Y-%m-%d %H:%M:%S UTC")
            self.Externalizations[oper.path, 'timestamp'] = formatted_time


    def handleMissingOperator(self, old_op_path, old_rel_file_path, externalizationsFolder):
        """
        If the old operator was renamed, update the table row in place.
        Otherwise, remove it from the table.
        """
        try:
            if self.checkForRenaming(old_op_path, old_rel_file_path, externalizationsFolder):
                # We found a renamed operator + updated the old row,
                # so do NOT remove it from the table
                return
            else:
                # The operator is truly gone
                self.log(f"Operator '{old_op_path}' no longer exists!", "WARNING")
                
                # Find the row index before trying to remove
                row_index = None
                for i in range(1, self.Externalizations.numRows):
                    if self.Externalizations[i, 'path'].val == old_op_path:
                        row_index = i
                        break
                
                if row_index is not None:
                    self.RemoveListerRow(old_op_path, old_rel_file_path)
        except Exception as e:
            self.log(f"Error in handleMissingOperator", "ERROR", str(e))


    def checkForRenaming(self, old_op_path, old_rel_file_path, externalizationsFolder):
        """
        Goes through all externalized ops. If we find one that references
        old_rel_file_path, we handle it.
        """
        # Clean up any duplicates first
        self.cleanupDuplicateRows(old_op_path)
        
        all_ops = self.getOpsByPar(COMP) + self.getOpsByPar(DAT)
        for candidate_op in all_ops:
            if self.isRenamedOp(candidate_op, old_rel_file_path):
                self.updateRenamedOp(candidate_op, old_op_path, old_rel_file_path, externalizationsFolder)
                return True
        return False


    def isRenamedOp(self, oper, old_rel_file_path):
        """
        For a COMP, check .externaltox. For a DAT, check .file.
        If it matches old_rel_file_path exactly, we consider it a rename.
        """
        if oper.family == 'COMP':
            return str(Path(oper.par.externaltox.eval())) == str(Path(old_rel_file_path))
        else:
            return str(Path(oper.par.file.eval())) == str(Path(old_rel_file_path))


    def cleanupAllDuplicateRows(self):
        """
        Clean up all duplicate rows in the externalizations table using cleanupDuplicateRows method.
        """
        # Get all unique paths
        paths = set()
        for i in range(1, self.Externalizations.numRows):
            path = self.Externalizations[i, 'path'].val
            if path:  # Skip empty paths
                paths.add(path)
                
        # Use existing method to clean up duplicates for each path
        for path in paths:
            self.cleanupDuplicateRows(path)


    def cleanupDuplicateRows(self, path):
        """
        Removes duplicate rows for a given path, keeping only the most recently updated one.
        Returns the index of the row to keep.
        """
        row_indices = []
        timestamps = []
        
        # Find all rows with this path
        for i in range(1, self.Externalizations.numRows):
            if self.Externalizations[i, 'path'].val == path:
                row_indices.append(i)
                try:
                    # Parse the timestamp
                    timestamp_str = self.Externalizations[i, 'timestamp'].val
                    if timestamp_str:
                        timestamp = datetime.strptime(timestamp_str, "%Y-%m-%d %H:%M:%S UTC")
                    else:
                        timestamp = datetime.min
                except:
                    timestamp = datetime.min
                timestamps.append(timestamp)
        
        if len(row_indices) <= 1:
            return row_indices[0] if row_indices else None
            
        # Find the most recent row
        most_recent_idx = timestamps.index(max(timestamps))
        row_to_keep = row_indices[most_recent_idx]
        
        # Remove all other rows
        for i in sorted(row_indices, reverse=True):
            if i != row_to_keep:
                self.Externalizations.deleteRow(i)
                self.log(f"Removed duplicate row {i} for path {path}", "INFO")
                
        return row_to_keep


    def updateRenamedOp(self, new_op, old_op_path, old_rel_file_path, externalizationsFolder):
        """
        Updates the externalizations table and file system when an operator is renamed.
        """
        try:
            # First check if we already have a row for the new path
            for i in range(1, self.Externalizations.numRows):
                if self.Externalizations[i, 'path'].val == new_op.path:
                    # Already have an entry for this new path - clean it up first
                    self.cleanupDuplicateRows(new_op.path)
                    break

            # Then clean up any rows with the old path
            row_index = self.cleanupDuplicateRows(old_op_path)
            if row_index is None:
                self.log(f"Could not find row for '{old_op_path}' in externalizations table", "ERROR")
                return

            # Important: Clear the external path parameter and make it writable
            if new_op.family == 'COMP':
                new_op.par.externaltox.readOnly = False
                new_op.par.externaltox = ''
            else:
                new_op.par.file.readOnly = False
                new_op.par.file = ''

            # Generate new paths based on the operator's new name
            abs_folder_path, save_file_path, _, new_rel_file_path = self.getOpPaths(new_op, externalizationsFolder)

            # Create directory if needed
            abs_folder_path.mkdir(parents=True, exist_ok=True)

            # Remove the old file
            old_file = Path(project.folder) / old_rel_file_path
            old_folder = old_file.parent
            if old_file.is_file():
                try:
                    old_file.unlink()
                    self.log(f"Removed old file: {old_rel_file_path}", "INFO")
                    
                    # Immediately try to remove the parent directory if empty
                    try:
                        if old_folder.exists() and not any(old_folder.iterdir()):
                            old_folder.rmdir()
                            self.log(f"Removed empty directory: {old_folder}", "INFO")
                            
                            # Recursively check and remove parent directories if empty
                            current_dir = old_folder.parent
                            while current_dir.exists() and current_dir != Path(project.folder):
                                if not any(current_dir.iterdir()):
                                    current_dir.rmdir()
                                    self.log(f"Removed empty parent directory: {current_dir}", "INFO")
                                    current_dir = current_dir.parent
                                else:
                                    break
                    except Exception as e:
                        self.log(f"Error removing directories: {old_folder}", "ERROR", str(e))
                        
                except Exception as e:
                    self.log(f"Error removing old file: {old_rel_file_path}", "ERROR", str(e))


            # Save operator to new location with new name
            try:
                new_op.save(str(save_file_path))
                self.log(f"Saved new file: {new_rel_file_path}", "SUCCESS")
            except Exception as e:
                self.log(f"Error saving new file: {new_rel_file_path}", "ERROR", str(e))

            # Update the operator's external path parameter
            if new_op.family == 'COMP':
                new_op.par.externaltox = str(new_rel_file_path)
                new_op.par.externaltox.readOnly = True
                new_op.par.enableexternaltox = True
            else:
                new_op.par.file = str(new_rel_file_path)
                new_op.par.file.readOnly = True
                new_op.par.syncfile = True

            # Update the externalizations table
            try:
                timestamp = datetime.utcnow().strftime("%Y-%m-%d %H:%M:%S UTC")
                
                # Update all fields at once
                self.Externalizations[row_index, 'path'] = new_op.path
                self.Externalizations[row_index, 'type'] = new_op.type
                self.Externalizations[row_index, 'rel_file_path'] = new_rel_file_path
                self.Externalizations[row_index, 'timestamp'] = timestamp
                
                # Force a cook to ensure updates are processed
                self.Externalizations.cook(force=True)

                # Double-check no duplicates were created
                self.cleanupDuplicateRows(new_op.path)
                
                self.log(f"Successfully updated table row for '{new_op.path}'", "SUCCESS")
                
            except Exception as e:
                self.log(f"Error updating externalizations table", "ERROR", str(e))

        except Exception as e:
            self.log(f"Error in updateRenamedOp", "ERROR", str(e))


    def saveUpdatedExternalFile(self, oper, new_paths, old_rel_file_path):
        # Save out updated external file and clean up old files
        abs_folder_path, save_file_path = new_paths[0], new_paths[1]
        try:
            # Use Pathlib's mkdir method
            abs_folder_path.mkdir(parents=True, exist_ok=True)
            # Save the operator to the new path
            oper.save(str(save_file_path))
            # Clean up the old file
            self.cleanupOldFile(old_rel_file_path)
        except Exception as e:
            self.log(f"Error handling file operations for {oper.path}", "ERROR", str(e))


    def cleanupOldFile(self, old_rel_file_path):
        # Attempt to remove the old file and its directory if empty
        old_file_path = Path(old_rel_file_path)
        try:
            if old_file_path.exists():
                old_file_path.unlink()
                self.log(f"Removed old file: {old_file_path}", "INFO")
            else:
                self.log(f"No old file to remove at: {old_file_path}", "INFO")
        except Exception as e:
            self.log(f"Error removing old file '{old_file_path}'", "ERROR", str(e))

        # Try to remove the parent directory if it's empty
        try:
            parent_dir = old_file_path.parent
            parent_dir.rmdir()
            self.log(f"Folder '{parent_dir}' was empty and has been removed", "INFO")
        except OSError as e:
            # Directory not empty or other error
            pass
        except Exception as e:
            self.log(f"Error removing directory '{parent_dir}'", "ERROR", str(e))


    def isInsideClone(self, oper):
        # Traverse up the parent hierarchy
        while oper:
            # Check if operator is a clone
            if oper.family == 'COMP' and oper.par.clone.eval():
                # If this is a master clone (clone parameter matches its name), allow it
                if oper.name in str(oper.par.clone.eval()):
                    oper = oper.parent()
                    continue
                return True
            oper = oper.parent()
        return False


    def isClone(self, oper):
        # Checks if the given operator is a clone by checking its clone parameter
        # Returns False for master clones (where clone parameter equals the operator's name)
        if oper.family == 'COMP' and oper.par.clone.eval():
            # If clone parameter equals the operator's name, it's a master clone - allow it
            if oper.name in str(oper.par.clone.eval()):
                return False
            # Otherwise it's a regular clone
            return True
        return False


    def isReplicant(self, oper):
        # Traverse up the parent hierarchy
        while oper:
            # Check if operator is a replicant
            if oper.family == 'COMP' and oper.replicator:
                return True
            oper = oper.parent()
        return False


    ''' UPDATE '''

    def Update(self):
        '''
        Embody's main enable/update method.
        Check for duplicates, retrieve tags and determine
        added/removed tags, and pass them to the
        addition/subtraction handler methods to process them.
        '''
        if self.my.par.Status == 'Enabled':

            # Check for parameter changes in COMPs
            for comp in self.getExternalizedOps(COMP):
                if self.param_tracker.compareParameters(comp):
                    # Parameters changed, mark as dirty
                    self.Externalizations[comp.path, 'dirty'] = 'Par'
                    self.Save(comp.path)
                # Update stored parameters
                #self.param_tracker.updateParamStore(comp)

            # Check for / fix duplicates
            if self.my.par.Detectduplicatepaths:
                self.checkForDuplicates()

            # Get lists
            all_tags = self.getTags()
            ops_by_par = self.getOpsByPar(COMP) + self.getOpsByPar(DAT)
            ops_to_externalize = self.getOpsToExternalize(COMP) + self.getOpsToExternalize(DAT)
            externalized_ops = self.getExternalizedOps(COMP) + self.getExternalizedOps(DAT)

            # Get additions/subtractions
            additions = [
                oper for oper in ops_to_externalize
                if oper.path not in [ext.path for ext in externalized_ops]
                and set(all_tags).intersection(oper.tags)
                and self.isOpProcessable(oper)
            ]
            
            subtractions = [
                oper for oper in externalized_ops
                if not set(all_tags).intersection(oper.tags)
                and not oper.warnings()
                and not oper.scriptErrors()
                and self.isOpProcessable(oper)
            ]

            regular_additions = []

            # Sort additions to ensure a specific order if needed
            additions.sort(key=lambda x: (self.Externalizations.path in x.path, x.path), reverse=True)

            # Process additions
            for oper in additions:
                self.handleAddition(oper)
                regular_additions.append(oper)

            # Process subtractions
            for oper in subtractions:
                self.handleSubtraction(oper)

            # Handle potentially dirty COMPs to update them
            dirties = self.dirtyHandler(True)

            # Reporting results
            plural = any(len(lst) > 1 for lst in [dirties, regular_additions, subtractions])
            self.printResults(dirties, regular_additions, subtractions, plural)

            # Refresh display
            run(f"op('{self.my}').par.Refresh.pulse()", delayFrames=1)
            self.updateEnableButtonLabel('Update')


    def checkForDuplicates(self):
        # Check for duplicate OPs, handling both unique and referenced externalizations
        def is_inside_clone(op):
            while op:
                if op.family == 'COMP':
                    try:
                        if op.par.clone and op.par.clone.eval():
                            return True
                    except:
                        if op.par.clone.expr:
                            return True
                op = op.parent()
            return False

        # Get all Embody tags
        embody_tags = self.getTags()
        
        # Collect all existing external tox/file paths
        external_paths = {}
        duplicate_ops = []

        # Check COMPs
        for op in self.root.findChildren(type=COMP, parName='externaltox'):
            # Skip if not tagged with an Embody tag
            if not any(tag in op.tags for tag in embody_tags):
                continue
            
            if is_inside_clone(op):
                continue  # Skip operators inside clone COMPs
            
            path = op.par.externaltox.eval()
            if path:
                # Normalize path
                path = str(Path(path))
                if path in external_paths:
                    duplicate_ops.append((op, external_paths[path]))
                else:
                    external_paths[path] = op

        # Check DATs
        for op in self.root.findChildren(type=DAT, parName='file'):
            # Skip if not tagged with an Embody tag
            if not any(tag in op.tags for tag in embody_tags):
                continue
            
            if is_inside_clone(op):
                continue  # Skip operators inside clone COMPs
            
            path = op.par.file.eval()
            if path:
                # Normalize path to use forward slashes
                path = path.replace('\\', '/')
                if path in external_paths:
                    duplicate_ops.append((op, external_paths[path]))
                else:
                    external_paths[path] = op

        # Process duplicates
        for new_op, existing_op in duplicate_ops:
            # Skip if the new_op already has the 'clone' tag
            if 'clone' in new_op.tags:
                continue

            op_path = new_op.path
            op_type = new_op.family
            message = (f"Duplicate external file path detected for {op_type} '{op_path}'.\n\n"
                      f"Choose 'Reference' to keep using the same external file (adds 'clone' tag),\n"
                      f"or 'Duplicate' to create a new externalization.")
            
            choice = ui.messageBox('Duplicate External Path Detected', message, 
                                 buttons=['Cancel', 'Reference', 'Duplicate'])

            if choice == 1:  # Reference
                # Add the 'clone' tag to mark this as an intentional reference
                new_op.tags.add('clone')
                new_op.color = (self.my.par.Clonetagcolorr, self.my.par.Clonetagcolorg, self.my.par.Clonetagcolorb)
                
                # Get the externalization path
                rel_file_path = new_op.par.externaltox.eval() if new_op.family == 'COMP' else new_op.par.file.eval()
                
                # Add to externalizations table if not already there
                row_exists = False
                for row in range(1, self.Externalizations.numRows):
                    if self.Externalizations[row, 'path'] == new_op.path:
                        row_exists = True
                        break
                
                if not row_exists:
                    timestamp = datetime.utcnow().strftime("%Y-%m-%d %H:%M:%S UTC")
                    dirty = ''
                    build_num = ''
                    touch_build = ''
                    
                    # For COMPs, include build info
                    if new_op.family == 'COMP':
                        build_num = int(new_op.par.Build.eval()) if hasattr(new_op.par, 'Build') else 1
                        touch_build = str(new_op.par.Touchbuild.eval()) if hasattr(new_op.par, 'Touchbuild') else app.build
                    
                    # Add to table
                    self.Externalizations.appendRow([new_op.path, new_op.type, rel_file_path, timestamp, dirty, build_num, touch_build])
                
                self.log(f"Added 'clone' tag to {op_path} - now referencing same external file", "SUCCESS")
                
            elif choice == 2:  # Duplicate
                # Clear the external path and update to create a new externalization
                if op_type == 'COMP':
                    new_op.par.externaltox = ''
                    self.Update()
                else:
                    new_op.par.file = ''
                    self.Update()
                self.log(f"Created new externalization for {op_path}", "SUCCESS")


    def handleAddition(self, oper):
        # Process COMPs/DATs added to Embody for externalization
        if oper.family == 'COMP':

            # Create or get the build info page
            build_page = None
            for page in oper.customPages:
                if page.name == 'Build Info':
                    build_page = page
                    break
            
            if not build_page:
                build_page = oper.appendCustomPage('About')
            
            # Get current build number from table or start at 1
            current_build = 1
            if hasattr(oper.par, 'Build'):
                current_build = oper.par.Build.eval()
            else:
                # Only check table for build number if COMP doesn't have param
                for row in range(1, self.Externalizations.numRows):
                    if self.Externalizations[row, 'path'].val == oper.path:
                        try:
                            current_build = int(self.Externalizations[row, 'build'].val)
                        except:
                            pass
                        break
            
            # Get Touch build number
            touch_build = app.build
            
            # Create or update parameters
            self.setupBuildParameters(oper, build_page, current_build, touch_build)

            # Use existing externaltox path if one exists
            if oper.par.externaltox.eval():
                rel_file_path = oper.par.externaltox.eval()
                abs_folder_path = Path(project.folder) / Path(rel_file_path).parent
                save_file_path = Path(project.folder) / rel_file_path
            else:
                # Only generate new paths if no existing externaltox
                abs_folder_path, save_file_path, rel_directory, rel_file_path = self.getOpPaths(oper, self.my.par.Folder.val)

            try:
                Path(abs_folder_path).mkdir(parents=True, exist_ok=True)
            except FileExistsError:
                pass

            # Don't modify existing externaltox path
            if not oper.par.externaltox.eval():
                oper.par.externaltox = rel_file_path
            
            oper.par.externaltox.readOnly = True
            oper.par.enableexternaltox = True
            oper.save(save_file_path)
            
            dirty = oper.dirty
            timestamp = datetime.utcnow().strftime("%Y-%m-%d %H:%M:%S UTC")

            if "Cannot load external tox from path" in oper.scriptErrors():
                oper.allowCooking = False
                run(f"op('{oper}').allowCooking = True", delayFrames = 1)

            # Store initial parameter state
            self.param_tracker.updateParamStore(oper)
            
        elif oper.family == 'DAT':
            # Use existing file path if one exists
            if oper.par.file.eval():
                rel_file_path = oper.par.file.eval()
                abs_folder_path = Path(project.folder) / Path(rel_file_path).parent
                save_file_path = Path(project.folder) / rel_file_path
            else:
                # Only generate new paths if no existing file path
                abs_folder_path, save_file_path, rel_directory, rel_file_path = self.getOpPaths(oper, self.my.par.Folder.val)

            try:
                Path(abs_folder_path).mkdir(parents=True, exist_ok=True)
            except FileExistsError:
                pass
                
            # Don't modify existing file path
            if not oper.par.file.eval():
                oper.par.file = str(rel_file_path)
                
            oper.par.syncfile = True
            run(f"op('{oper}').par.syncfile = False", delayFrames = 1)
            run(f"op('{oper}').par.syncfile = True", delayFrames = 2)
            oper.par.file.readOnly = True
            oper.save(str(save_file_path))
            dirty = ''
            timestamp = datetime.utcnow().strftime("%Y-%m-%d %H:%M:%S UTC")

        # Always add to table
        row_exists = False
        for row in range(1, self.Externalizations.numRows):
            if self.Externalizations[row, 'path'] == oper.path:
                row_exists = True
                # Update existing entry if path changed
                self.Externalizations[row, 'rel_file_path'] = rel_file_path
                break

        # For COMPs, get build info
        build_num = ''
        touch_build = ''
        if oper.family == 'COMP':
            build_num = int(oper.par.Build.eval()) if hasattr(oper.par, 'Build') else 1
            touch_build = str(oper.par.Touchbuild.eval()) if hasattr(oper.par, 'Touchbuild') else app.build

        if not row_exists:
            self.Externalizations.appendRow([oper.path, oper.type, rel_file_path, timestamp, dirty, build_num, touch_build])

        self.log(f"Added '{oper.path}'", "SUCCESS")


    def handleSpecialCaseAddition(self, oper):
        # Manage special cases
        # Example action for special case: Log and skip usual processing
        #print(f"Special handling for: {oper.path}")
        # Add more actions as necessary for special cases
        pass


    def handleSubtraction(self, oper):
        # Process COMPs/DATs removed from Embody
        self.Externalizations.deleteRow(oper.path)
        if oper.family == 'COMP':
            oper.par.externaltox.readOnly = False
        elif oper.family == 'DAT':
            oper.par.file.readOnly = False
        self.log(f"Removed '{oper.path}'", "SUCCESS")


    def setupBuildParameters(self, oper, build_page, build_num, touch_build):
        """Setup or update build tracking parameters on a COMP"""
        # Build Number
        build_par = None
        for par in oper.customPars:
            if par.name == 'Build':
                build_par = par
                break
                
        if not build_par:
            build_par = build_page.appendInt('Build', label = 'Build Number')
            build_par.readOnly = True
            
        build_par.val = build_num
        
        # Date
        date_par = None
        for par in oper.customPars:
            if par.name == 'Date':
                date_par = par
                break
                
        if not date_par:
            date_par = build_page.appendStr('Date', label = 'Build Date')
            date_par.label = 'Build Date'
            date_par.readOnly = True
            
        date_par.val = datetime.utcnow().strftime("%Y-%m-%d %H:%M:%S UTC")
        
        # Touch Build
        touch_build_par = None
        for par in oper.customPars:
            if par.name == 'Touchbuild':
                touch_build_par = par
                break
                
        if not touch_build_par:
            touch_build_par = build_page.appendStr('Touchbuild', label = 'Touch Build')
            touch_build_par.readOnly = True
            
        touch_build_par.val = touch_build


    def printResults(self, dirties, additions, subtractions, plural):
        # Print results
        if dirties:
            self.log(f"Saved {dirties} tox{'es' if plural else ''}", "SUCCESS")
        if additions:
            self.log(f"Added {len(additions)} operator{'s' if plural else ''} in total", "SUCCESS")
        if subtractions:
            self.log(f"Removed {len(subtractions)} operator{'s' if plural else ''} in total", "SUCCESS")


    def getProjectFolder(self):
        # Fetch the TouchDesigner project folder (for file operations)
        if self.my.par.Folder.mode == ParMode.EXPRESSION:
            externalizations_folder = self.my.par.Folder.eval()
        else:
            externalizations_folder = str(Path(project.folder) / self.my.par.Folder)
        return externalizations_folder


    def UpdateHandler(self):
        # Re-init all marked externalizations
        # If already init'd, this functions as a normal Update
        if self.my.par.Status == 'Disabled':
            self.log("Enabled", "SUCCESS")
            self.my.par.Status = 'Enabled'

            # Initialize parameter tracking
            self.param_tracker.initializeTracking(self)

            # Create Embody folder if it doesn't exist
            externalizations_folder = self.getProjectFolder()
            try:
                os.mkdir(externalizations_folder)
                self.log(f"Created externalization folder '{externalizations_folder}'", "SUCCESS")
            except FileExistsError:
                pass

        run(f"op('{self.my}').Update()", delayFrames = 1)
        

    def Manager(self, action):
        # Open the viewer and refresh for latest status report
        win = self.my.op('window_manager')
        if action == 'open':
            win.par.winopen.pulse()
            self.Refresh()
        
        # Close it
        elif action == 'close':
            win.par.winclose.pulse()


    ''' TAGGING '''

    def getTagColorForOperator(self, oper, tag):
        """
        Return the color for the tag if it can be applied to the operator, otherwise None
        """
        if oper.family == 'COMP':
            if tag == self.my.par.Toxtag.val:
                return (self.my.par.Toxtagcolorr, self.my.par.Toxtagcolorg, self.my.par.Toxtagcolorb)
            else:
                self.log("TOX tags can only be applied to COMP operators", "ERROR")
                return None
        elif oper.family == 'DAT':
            if tag in self.getTags('DAT') and oper.type in self.supported_dat_oper_types:
                return (self.my.par.Dattagcolorr, self.my.par.Dattagcolorg, self.my.par.Dattagcolorb)
            else:
                self.log("DAT tags can only be applied to text/table/*execDAT operators", "ERROR")
                return None
        else:
            self.log("Embody tags can only be applied to COMPs or text/table/*execDAT operators", "ERROR")
            return None


    def applyTagToOperator(self, oper, tag):
        # Apply a tag/color to an OP
        color = self.getTagColorForOperator(oper, tag)
        if color is None:
            return False

        if tag not in oper.tags:
            oper.tags.add(tag)
            oper.color = color
            self.log(f"Tag '{tag}' applied to '{oper.path}'", "SUCCESS")
            
            # If COMP has existing externaltox, add it to the externalizations table
            if oper.family == 'COMP' and oper.par.externaltox and oper.par.externaltox.eval():
                rel_file_path = oper.par.externaltox.eval()
                timestamp = datetime.utcnow().strftime("%Y-%m-%d %H:%M:%S UTC")
                self.Externalizations.appendRow([oper.path, oper.type, rel_file_path, timestamp, oper.dirty])
                self.log(f"Added existing externalization '{rel_file_path}' to table", "SUCCESS")
        else:
            # Tag already present
            pass
        return True


    def TagSetter(self, oper, tag):
        # Process the addition or removal of a tag for an OP.
        #print('toggle tag ' + oper + 'tag: ' + tag)
        color = self.getTagColorForOperator(oper, tag)
        if color is None:
            return False

        #if oper.family == 'COMP' and oper.par.externaltox and oper.par.externaltox.eval() and tag not in oper.tags:
        #    ui.messageBox('Embody Warning', f"The operator '{oper.path}' already has an external tox file linked. Please remove the custom externaltox parameter to add this to Embody.", buttons=['Ok'])
        #    self.log(f"Warning: operator '{oper.path}' has an existing externaltox parameter. Remove the externaltox to add to Embody", "WARNING")
        #    return False

        if tag not in oper.tags:
            # Apply the tag
            oper.tags.add(tag)
            oper.color = color
            #print(f"{self.header} tag '{tag}' applied to '{oper.path}'.")
        else:
            # Remove the tag
            oper.tags.remove(tag)
            self.resetOpColor(oper)
            # Remove from externalizations
            rel_file_path = oper.par.externaltox.eval() if oper.family == 'COMP' else oper.par.file.eval()
            self.RemoveListerRow(oper.path, rel_file_path)
            # Clear external parameters
            if oper.family == 'COMP':
                oper.par.externaltox = ''
                oper.par.externaltox.readOnly = False
                #print(f"{self.header} externaltox parameter cleared for '{oper.path}' as the tag was removed.")
            elif oper.family == 'DAT':
                oper.par.file = ''
                oper.par.file.readOnly = False
                #print(f"{self.header} file parameter cleared for '{oper.path}' as the tag was removed.")
            #print(f"{self.header} tag '{tag}' removed from '{oper.path}'.")
        return True


    def getTags(self, selection=False):
        # Return a list of all tag pars from Embody custom pars
        tags = [par.val for par in self.my.pars('*tag')]
        if selection == 'tox':
            tags = [tag for tag in tags if tag == self.my.par.Toxtag.val]
        elif selection == 'DAT':
            tags = [tag for tag in tags if tag != self.my.par.Toxtag.val]
        return tags


    def TagExiter(self):
        # Close the Tagger UI window
        self.tagging_menu_window.par.winclose.pulse()


    def alternateColor(self, color):
        return f'{color} if me.digits % 2 else {color} - 0.05'


    def SetupTagger(self, oper):
        # Reset button colors
        params = self.tagger.op('tags')
        for i in range(1, params.numRows):
            button = self.tagger.op(f'button{i}')
            if button:
                button.par.colorr = self.my.par.Taggingmenucolorr
                button.par.colorg.expr = self.alternateColor(parent.Embody.par.Taggingmenucolorg)
                button.par.colorb = self.my.par.Taggingmenucolorb

        # Loop over all parameters (tags)
        for i in range(1, params.numRows):
            button = self.tagger.op(f'button{i}')
            if len(oper.tags) > 0:
                for tag in oper.tags:
                    # Mark active tags in menu
                    if tag == params[i, 'value'].val:
                        button.par.colorr = self.my.par.Toxtagcolorr if oper.family == 'COMP' else self.my.par.Dattagcolorr
                        button.par.colorg.expr = self.alternateColor(self.my.par.Toxtagcolorg) if oper.family == 'COMP' else self.alternateColor(self.my.par.Dattagcolorg)
                        button.par.colorb = self.my.par.Toxtagcolorb if oper.family == 'COMP' else self.my.par.Dattagcolorb


    def TagGetter(self):
        # Get the tags of the currently selected operator(s) and
        # Display them in the tagging menu
        params = self.tagger.op('tags')
        switch = self.tagger.op('switch_family')
        oper = ui.rolloverOp
        self.rolloverOp = oper

        show_dats = False
        show_toxes = False

        # Check if the operator is an unsupported type (engineCOMP)
        if oper.type == 'engine':
            ui.messageBox('Embody Error', f"Operator '{oper.path}' is of type '{oper.type}', which is not supported for tagging.", buttons=['Ok'])
            return  # Skip this operator

        # Check if the operator is a replicant or a clone
        if self.isReplicant(oper) or self.isClone(oper) or self.isInsideClone(oper):
            ui.messageBox('Embody Warning', f"Operator '{oper.path}' is either a replicant or a clone and cannot be externalized.\nNo tags will be applied to it.", buttons=['Ok'])
            return  # Skip this operator

        # Display only relevant tags (tox or DAT)
        if oper.type in self.supported_dat_oper_types:
            show_dats = True
        elif oper.family == 'COMP':
            show_toxes = True
        else:
            ui.messageBox('Embody Error', 'Embody Tags can only be applied to COMPs or text/table/*execDAT operators.', buttons=['Ok'])
            return

        # Display only relevant tags (tox or DAT)
        if not show_dats:
            switch.par.index = 2
        elif not show_toxes:
            switch.par.index = 1
        elif show_toxes and show_dats:
            switch.par.index = 0

        # Setup tagger only for eligible operators
        run(f"args[0](args[1])", self.SetupTagger, oper, delayFrames=1)
        run(f"op('{self.tagging_menu_window}').par.winopen.pulse()", delayFrames=2)


    ''' EXTERNALIZE FULL PROJECT '''

    def ExternalizeProject(self):
        # Prompt user for confirmation
        choice = ui.messageBox(
            'Embody',
            'This process will add every compatible COMP and DAT to Embody from your project.\nDerivative Palette components, clones and replicants will be ignored. \nDo you want to proceed?',
            buttons=['Cancel', 'Confirm']
        )
        if choice == 0:
            return  # User selected 'Cancel', so do nothing

        # Find all COMPs whose clone parameter contains 'sys'
        sys_comps = self.root.findChildren(
            type=COMP,
            parName='clone',
            key=lambda x: 'TDTox' in (str(x.par.clone.expr) or '') or 'TDBasicWidgets' in (str(x.par.clone.expr) or '')
            )

        # Build a set of paths to exclude (these COMPs and their descendants)
        paths_to_exclude = set()
        for sys_comp in sys_comps:
            paths_to_exclude.add(sys_comp.path)
            # Add all descendants
            descendants = sys_comp.findChildren()
            for desc in descendants:
                paths_to_exclude.add(desc.path)

        # Find all compatible DATs and COMPs
        compatible_dats = self.root.findChildren(type=DAT, parName='file')
        compatible_comps = self.root.findChildren(type=COMP, parName='externaltox')
        
        # For DATs
        for oper in compatible_dats:
            # Skip operators that are in paths to exclude
            if oper.path in paths_to_exclude:
                continue
            # Skip DATs inside clones or replicators
            if self.isReplicant(oper) or self.isInsideClone(oper):
                continue
            # Exclude operators under '/local/'
            if oper.path.startswith('/local/') or oper.path == '/local':
                continue

            # Apply tags to certain DAT types
            if oper.type in self.supported_dat_oper_types:
                tag_param = self.dat_type_to_tag.get(oper.type, 'Pytag')

                # Special handling for TextDATs with extensions and language
                if oper.type == 'text':
                    extension = oper.par.extension.eval() if hasattr(oper.par, 'extension') else ''
                    language = oper.par.language.eval() if hasattr(oper.par, 'language') else ''

                    # Check language first, then extension
                    if language in self.extension_language_to_tag:
                        tag_param = self.extension_language_to_tag[language]
                    elif extension in self.extension_language_to_tag:
                        tag_param = self.extension_language_to_tag[extension]

                tag_value = getattr(self.my.par, tag_param).eval()
                self.ApplyTagToOperator(oper, tag_value)

            else:
                continue  # Skip other DAT types
        
        # For COMPs

        # Get the COMP tag
        comp_tag = self.my.par.Toxtag.val  # Should be the TOX tag
        
        for oper in compatible_comps:
            # Skip operators that are in paths to exclude
            if oper.path in paths_to_exclude:
                continue
            # Skip COMPs inside clones or replicators
            if self.isReplicant(oper) or self.isInsideClone(oper):
                continue
            # Exclude operators under '/local/'
            if oper.path.startswith('/local/') or oper.path == '/local':
                continue
            # Apply the TOX tag
            self.ApplyTagToOperator(oper, comp_tag)

        # Update Embody
        self.UpdateHandler()


    def ApplyTagToOperator(self, oper, tag):
        # Apply tag to an operator
        success = self.applyTagToOperator(oper, tag)
        if not success:
            self.log(f"Failed to apply tag '{tag}' to '{oper.path}'", "ERROR")


    ''' UTILITIES '''

    def isOpProcessable(self, oper):
        # Handle replications, clones and ignore the /local directory
        return (
            not self.isReplicant(oper) and
            not self.isInsideClone(oper) and
            not oper.path.startswith('/local/') and
            oper.path != '/local' and
            oper.type != 'engine' and
            oper.type != 'time' and
            oper.type != 'annotate'
        )


    def RemoveListerRow(self, op_path, rel_file_path):
        # Remove the externalized op from the Lister COMP
        is_clone = False
        try:
            oper = op(op_path)
            if oper:
                # Check if this is a cloned externalization
                if 'clone' in oper.tags:
                    is_clone = True
                    self.log(f"Skipping file deletion for cloned externalization: {op_path}", "INFO")
                
                # Remove tags and reset parameters if the operator still exists
                tags = [tag for tag in self.getTags() if tag in oper.tags]
                for tag in tags:
                    oper.tags.remove(tag)
                if oper.family == 'COMP':
                    oper.par.externaltox = ''
                    oper.par.externaltox.readOnly = False
                    oper.cook(force=True)
                elif oper.family == 'DAT':
                    oper.par.syncfile = False
                    oper.par.file = ''
                    oper.par.file.readOnly = False
                    oper.cook(force=True)
                self.resetOpColor(oper)
                self.param_tracker.removeComp(op_path)
        except Exception as e:
            self.log(f"Error handling operator parameters for '{op_path}'", "ERROR", str(e))

        # Check if any other operators reference the same file
        other_references = False
        if rel_file_path:
            # Check COMPs
            for comp in self.root.findChildren(type=COMP, parName='externaltox'):
                if comp.path != op_path and comp.par.externaltox.eval() == rel_file_path:
                    other_references = True
                    self.log(f"File '{rel_file_path}' is still referenced by '{comp.path}'", "INFO")
                    break
            
            # Check DATs
            if not other_references:
                for dat in self.root.findChildren(type=DAT, parName='file'):
                    if dat.path != op_path and dat.par.file.eval() == rel_file_path:
                        other_references = True
                        self.log(f"File '{rel_file_path}' is still referenced by '{dat.path}'", "INFO")
                        break

        # Only attempt to remove the file if no other operators reference it
        # We completely ignore the 'clone' tag here - the only thing that matters
        # is whether other operators still reference this file
        if rel_file_path and not other_references:
            full_file_path = Path(project.folder) / rel_file_path
            full_file_path = full_file_path.resolve()

            def delete_file():
                try:
                    if full_file_path.is_file():
                        full_file_path.unlink()
                        self.log(f"Removed external file: {rel_file_path}", "INFO")
                    else:
                        self.log(f"No external file found to remove for '{op_path}': {rel_file_path}", "WARNING")
                except Exception as e:
                    self.log(f"Error removing file '{rel_file_path}'", "ERROR", str(e))

            # Delay the deletion to ensure the file handle is released
            run(delete_file, delayFrames=5)
        else:
            # File should not be deleted: it's either a clone or has other references
            if is_clone or other_references:
                self.log(f"Preserved external file '{rel_file_path}' as it's still in use", "INFO")
            # Otherwise rel_file_path is empty; no file to remove
            pass

        # Remove the row from the externalizations table
        try:
            self.Externalizations.deleteRow(op_path)
            self.log(f"Removed '{op_path}' from table", "SUCCESS")
        except Exception as e:
            self.log(f"Error removing '{op_path}' from table", "ERROR", str(e))


    def getSaveFolder(self):
        # Return the Save folder par
        if self.my.par.Folder.expr:
            folder = self.my.par.Folder.eval()
        else:
            folder = project.folder + '/' + self.my.par.Folder

        return folder


    def OpenSaveFolder(self):
        # Get the save folder path using pathlib for cross-platform compatibility
        save_folder = Path(self.getSaveFolder()).resolve()
        save_folder_str = str(save_folder)

        if sys.platform.startswith('darwin'):
            # macOS: Use 'open' to open the folder in Finder
            subprocess.call(['open', save_folder_str])
        elif sys.platform.startswith('win'):
            # Windows: Use os.startfile to open the folder in Explorer
            os.startfile(save_folder_str)


    def OpenSaveFile(self, rel_file_path):
        # Build the full path using pathlib for cross-platform compatibility
        filepath = Path(project.folder) / rel_file_path

        # Ensure the path is absolute and resolve any symlinks
        filepath = filepath.resolve()

        # Convert the path to a string
        filepath_str = str(filepath)

        if sys.platform.startswith('darwin'):
            # macOS: Use 'open -R' to reveal the file in Finder
            subprocess.call(['open', '-R', filepath_str])
        elif sys.platform.startswith('win'):
            # Windows: Use 'explorer /select,' to open Explorer and select the file
            # Replace forward slashes with backslashes in the path
            filepath_str = filepath_str.replace('/', '\\')
            subprocess.call(['explorer', '/select,', filepath_str])


    def OpenTable(self):
        # Open the externalizations tableDAT viewer
        self.Externalizations.openViewer()


    def deleteEmptyDirectories(self, path):
        """ Recursively delete empty directories until none are left. """
        empty_dir_found = True
        iteration_count = 0
        while empty_dir_found and iteration_count < 10:  # Limit iterations to avoid infinite loops in case of errors
            empty_dir_found = False
            iteration_count += 1
            for root, dirs, files in os.walk(path, topdown=False):
                for dir in dirs:
                    dir_path = str(Path(root) / dir)
                    if not list(Path(dir_path).iterdir()):  # Check if the directory is empty
                        try:
                            Path(dir_path).rmdir()
                            self.log(f"Deleted empty directory: {dir_path}", "INFO")
                            empty_dir_found = True  # Set flag to True if a directory was deleted
                        except OSError as e:
                            # Logging the error and continuing
                            self.log(f"Error deleting directory: {dir_path}", "ERROR", str(e))

        if empty_dir_found:
            self.log(f"Warning: Could not delete some empty directories after {iteration_count} iterations", "WARNING")


    def deleteFile(self, oper, externalizationsFolder):
        # Remove externalized file from file system
        abs_folder_path, save_file_path, rel_directory, rel_file_path = self.getOpPaths(oper, externalizationsFolder)
        if save_file_path is None:
            return  # Can't proceed without a valid path

        save_file = save_file_path.resolve()
        try:
            if save_file.exists():
                save_file.unlink()
                self.log(f"Deleted file: {save_file}", "INFO")
                # Attempt to remove the file directory (if empty)
                try:
                    abs_folder_path.rmdir()
                except OSError:
                    # Directory not empty
                    pass
            else:
                # File does not exist
                pass

        except FileNotFoundError:
            self.log(f"File not found: {save_file}", "WARNING")
        except PermissionError:
            # Insufficient permissions to delete the file
            pass
        except Exception as e:
            # Handle other exceptions
            pass


    def resetOpColor(self, oper):
        # Reset operator color to default value
        oper.color = (0.55, 0.55, 0.55)


    def MissingExternalizationsPar(self):
        self.log("Embody is missing an Externalization tableDAT, which is required to function", "ERROR")


    def log(self, message, level='INFO', details=None):
        """
        Centralized logging method for Embody.
        
        Args:
            message (str): The main message to log
            level (str): Log level - 'INFO', 'WARNING', 'ERROR', or 'SUCCESS'
            details (str, optional): Additional details to include after the main message
        """
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        
        # Define level prefixes
        level_prefixes = {
            'INFO': '',
            'WARNING': '[WARNING] ',
            'ERROR': '[ERROR] ',
            'SUCCESS': '[SUCCESS] '
        }
        
        # Format the log message
        prefix = f"[{timestamp}] {self.header}"
        if level in level_prefixes:
            prefix += f" {level_prefixes[level]}"
        
        # Construct the full message
        full_message = f"{prefix} {message}"
        if details:
            full_message += f"\n    Details: {details}"
            
        # Add divider for certain message types
        #if level in ['ERROR', 'SUCCESS']:
        #    full_message = f"{self.divider}\n{full_message}\n{self.divider}"
            
        print(full_message)


class ParameterTracker:
    def __init__(self, ownerComp):
        self.my = ownerComp
        # Store parameter snapshots for each COMP
        self.param_store = {}
        
    def captureParameters(self, comp):
        """Capture all parameters of a COMP, including built-in ones"""
        params = {}
        # Get all parameter pages (built-in and custom)
        for page in comp.pages + comp.customPages:
            for par in page.pars:
                # Skip certain parameters that shouldn't trigger dirty state
                if par.name in ['externaltox', 'file']:
                    continue
                    
                # Store both the value and expression if it exists
                params[par.name] = {
                    'value': par.eval(),
                    'expr': par.expr if par.expr else None,
                    'mode': par.mode
                }
                
        return params
    
    def updateParamStore(self, comp):
        """Update stored parameters for a COMP"""
        self.param_store[comp.path] = self.captureParameters(comp)
        
    def compareParameters(self, comp):
        """
        Compare current parameters with stored ones
        Returns True if parameters have changed, including additions or deletions
        """
        if comp.path not in self.param_store:
            self.updateParamStore(comp)  # Initialize tracking if not already tracking
            return False
            
        stored_params = self.param_store[comp.path]
        current_params = self.captureParameters(comp)
        
        # Check for any new parameters
        for name in current_params:
            if name not in stored_params:
                return True  # New parameter added
                
        # Check for any removed parameters
        for name in stored_params:
            if name not in current_params:
                return True  # Parameter was removed
            
            # If parameter exists in both, compare values
            stored = stored_params[name]
            current = current_params[name]
            
            # Compare values and expressions
            if stored['value'] != current['value']:
                return True
            if stored['expr'] != current['expr']:
                return True
            if stored['mode'] != current['mode']:
                return True
                
        return False
    
    def removeComp(self, comp_path):
        """Remove a COMP's parameters from storage"""
        if comp_path in self.param_store:
            del self.param_store[comp_path]

    def initializeTracking(self, embody):
        """Initialize parameter tracking for all externalized COMPs"""
        # Clear existing store
        self.param_store = {}
        # Initialize tracking for all externalized COMPs
        for comp in embody.getExternalizedOps(COMP):
            self.updateParamStore(comp)
            embody.log(f"Initialized parameter tracking for {comp.path}", "INFO")

