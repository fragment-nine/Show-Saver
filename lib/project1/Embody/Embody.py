"""
Embody automatically creates, maintains and updates
tox and DAT file externalizations for your project,
supporting a variety of file formats.

Simply add your preferred tags for COMPs/DATs to be saved,
and on ctrl-s external file references will automatically 
be created and/or updated.
"""
import os
import subprocess
import sys
import re
from datetime import datetime, timedelta
import time
import shutil
import TDFunctions as TDF
from pathlib import Path
import random
import string

class Embody:

    def __init__(self, ownerComp):
        # definitions
        self.my = ownerComp
        self.folder_dat = self.my.op('folder1')
        self.lister = self.my.op('list/treeLister')
        self.tagging_menu_window = self.my.op('window_tagging_menu')
        self.tagger = self.my.op('tagger')
        self.mouse = self.my.op('mousein1')
        self.root = op('/')
        self.divider = '- - -'
        self.complete = '<===========================================>\n'
        self.header = f'Embody v{self.my.par.Version.val} >'
        self.supported_dat_oper_types = ['text', 'table', 'execute', 'parexec', 'pargroupexec', 'chopexec', 'datexec', 'opexec', 'panelexec']

        # Mapping of DAT types to default tags
        self.dat_type_to_tag = {
            'text': 'Txttag',
            'table': 'Dattag',
            'execute': 'Pytag',
            'parexec': 'Pytag',
            'pargroupexec': 'Pytag',
            'chopexec': 'Pytag',
            'datexec': 'Pytag',
            'opexec': 'Pytag',
            'panelexec': 'Pytag'
        }

        # Mapping of file extensions to tags for TextDATs
        self.extension_language_to_tag = {
            'csv': 'Csvtag',
            'dat': 'Dattag',
            'frag': 'Glsltag',
            'glsl': 'Glsltag',
            'html': 'Htmltag',
            'json': 'Jsontag',
            'md': 'Mdtag',
            'py': 'Pytag',
            'rtf': 'Rtftag',
            'tsv': 'Csvtag',
            'txt': 'Txttag',
            'vert': 'Glsltag',
            'xml': 'Xmltag',
            'yml': 'Jsontag',
            'python': 'Pytag',
            'yaml': 'Jsontag',
            'xml': 'Xmltag',
            'tscript': 'Pytag',
            'text': 'Txttag'
        }

        # properties
        TDF.createProperty(self, 'SelectedOps', value='', dependable=True, readOnly=False)

    @property
    def Externalizations(self):
        return self.my.par.Externalizations.eval()

    @property
    def ExternalizationsFolder(self):
        # Return the project folder
        # Return empty string for relative directory paths
        folder = self.my.par.Folder.eval()
        if folder:
            return folder
        else:
           return ''

    ''' INIT '''

    def Reset(self, removeTags=False):
        # Reset (as this is a new instance of Embody)
        parent.Embody.Disable(False, removeTags)
        run(f"op('{self.my}').UpdateHandler()", delayFrames = 10)

        # Generate the externalizations tableDAT
        self.createExternalizationsTable()

        # Initialize mouse so Tagger functions on first use
        #self.mouse.par.active = 1
        #run(f"op('{self.mouse}').par.active = 0", delayFrames = 3)

        # Clear externaltox path (auto generated by Derivative when adding a component to a network)
        self.my.par.externaltox = ''


    def createExternalizationsTable(self):  
        # Create a tableDAT for externalizations 
        # Name of the externalizations tableDAT
        table_name = 'externalizations'

        # Check if the tableDAT exists
        externalizations_dat = self.Externalizations
        if not externalizations_dat:
            # Create the tableDAT
            externalizations_dat = self.my.parent().create(tableDAT, table_name)
            # Position it next to Embody COMP
            externalizations_dat.nodeX = self.my.nodeX - 200
            externalizations_dat.nodeY = self.my.nodeY
            # Dock the tableDAT to the Embody COMP
            externalizations_dat.dock = self.my
            externalizations_dat.color = (self.my.par.Dattagcolorr, self.my.par.Dattagcolorg, self.my.par.Dattagcolorb)

            # Set the headers
            externalizations_dat.clear()
            externalizations_dat.appendRow(['path', 'type', 'rel_file_path', 'timestamp', 'dirty'])

            # add tableDAT tag
            externalizations_dat.tags = [self.my.par.Dattag.eval()]

            print(f"{self.header} created and docked '{table_name}' tableDAT.")
        else:
            # If it exists, clear it
            externalizations_dat.clear(keepFirstRow=True)
            print(f"{self.header} reset '{table_name}' tableDAT.")
        
        # Assign created tableDAT to the 'Externalizations' parameter
        self.my.par.Externalizations.val = externalizations_dat


    def Verify(self):
        # Check if Embody already exists in the project
        embodies = op('/').findChildren(name='Embody', parName='Addtagshort')
        this_embody = self.my
        already_here = 0
        for embody in embodies:
            if embody != this_embody:
                already_here = embody
        if already_here != 0:
            ui.messageBox('Embody', f'An instance of Embody has already been detected in this project.\nPlease remove the existing instance first:\n{already_here}', buttons=['Ok'])
        # If it doesn't exist, prompt user if they want to reset
        do_reset = ui.messageBox('Embody', 'It looks like this is a new instance of Embody.\nWould you like to reset (initialize) it from the previously saved state?\n(If unsure, go with, "Yes").', buttons=['No', 'Yes'])
        if do_reset:
            self.Reset()


    ''' DISABLE '''

    def Disable(self, prevFolder=False, removeTags=False):
        '''
        Clear external tox/DAT file paths on all ops that have them and
        delete all externalized files (tox/DAT) from the Embody folder.
        Delete tags as well if removeTags input is True
        '''
        folder = self.ExternalizationsFolder if prevFolder == None else prevFolder
        if prevFolder == '':
            folder = project.folder

        tags = self.getTags()
        for oper in self.getExternalizedOps(COMP):
            oper.par.externaltox = ''
            self.deleteFile(oper, folder)
            if removeTags:
                removal = [oper.tags.remove(old_tag) for old_tag in tags if old_tag in oper.tags]
                self.resetOpColor(oper)

        for oper in self.getExternalizedOps(DAT):
            try:
                oper.par.syncfile = False
                oper.par.file = ''
            except Exception as e:
                #print(e)
                pass
        
            self.deleteFile(oper, folder)

            if removeTags:
                if str(self.Externalizations) not in oper.path:
                    removal = [oper.tags.remove(old_tag) for old_tag in tags if old_tag in oper.tags]
                    self.resetOpColor(oper)

        # Disable folderDAT
        self.folder_dat.par.active = 0

        # Disable externalizations table external tag
        #if self.Externalizations:
        #    self.Externalizations.tags = []

        # Delete any rogue (empty) folders from the Embody folder
        # for row in range(1, self.folder_dat.numRows):
        #     path = Path(folder) / self.folder_dat[row, 'relpath'].val
        #     try:
        #         path.rmdir()
        #     except Exception as e:
        #         pass

        # Find all top-level COMP operators
        top_level_comps = self.root.findChildren(depth=1, type=COMP)

        # Iterate over these COMPs and attempt to remove their corresponding directories
        for comp in top_level_comps:
            if comp.name not in ['local', 'perform']:
                comp_path = Path(f'{folder}/{comp.name}')
                if comp_path.is_dir() and not any(comp_path.iterdir()):  # Check if directory is empty
                    try:
                        comp_path.rmdir()
                    except Exception as e:
                        print(f"{self.header} error removing directory [{comp_path}]: {e}")

        # After attempting to delete subdirectories, check if the externalizations folder itself is now empty and remove it if it is
        try:
            if folder:
                Path(folder).rmdir()
                print(f"{self.header} removed directory {folder}")
        except Exception as e:
            #print(f"Error removing directory [{self.ExternalizationsFolder}]: {e}")
            pass

        # Attempt to delete old externalization folder (if changed from current project folder)
        if prevFolder and prevFolder != self.getProjectFolder():
            prev_folder_path = Path(prevFolder)
            if prev_folder_path.is_dir() and prev_folder_path != Path(self.getProjectFolder()):
                try:
                    shutil.rmtree(prev_folder_path, ignore_errors=True)
                    print(f"{self.header} removed old externalization folder {prev_folder_path}")
                except Exception as e:
                    print(f"{self.header} error removing directory [{prev_folder_path}]: {e}")

        else: # Using project folder
            pass

        # Clear and delete table if it exists
        if self.Externalizations:
            run(f"op('{self.Externalizations}').clear(keepFirstRow=True)", delayFrames = 10)

            def delayedDelete():
                self.deleteFile(self.Externalizations, folder)
            
            # Use run() to schedule the deletion after the table is cleared
            run(delayedDelete, delayFrames=11)

        # Set status to false for save out so 
        # Files are not automatically externalized again until re-init
        self.my.par.Status = 'Disabled'

        # Update init button label in manager to 'initialize' as that is the next step
        self.updateEnableButtonLabel('Enable')

        # Delete empty directories in project folder
        def deleteEmpties():
            if folder:
                self.deleteEmptyDirectories(folder)

        run(deleteEmpties, delayFrames = 60)

        print(f'{self.divider}\n{self.header} disabled\n{self.divider}')


    def DisableHandler(self):
        # Prompt user if they want to reset Embody, before resetting
        choice = ui.messageBox('Embody Warning', 'Are you sure you want to disable Embody?\nAll externalized files will be deleted and tox/DAT file parameters cleared.', buttons=['No', 'Yes, keep all Embody Tags', 'Yes, remove all Embody Tags'])
        if choice:
            self.Disable(self.ExternalizationsFolder, choice - 1)


    ''' GET OPS '''

    def getOpPaths(self, opToExternalize, externalizationsFolder):
        if externalizationsFolder == False:
            externalizationsFolder = self.ExternalizationsFolder

        # Return abs_folder_path, save_file_path, rel_directory, and rel_file_path
        if opToExternalize.family == 'COMP':
            file_extension = '.tox'
        elif opToExternalize.family == 'DAT':
            tags = self.getTags()
            found = [tag for tag in opToExternalize.tags if tag in tags]
            file_extension = f'.{found[0]}' if found else None

        if file_extension is not None:
            # Get the operator path components
            op_path_components = opToExternalize.path.strip('/').split('/')
            # Build the relative directory path
            rel_directory = Path(externalizationsFolder, *op_path_components[:-1])
            # Build the filename
            filename = opToExternalize.name + file_extension
            # Build the full relative file path
            rel_file_path = rel_directory / filename
            # abs_folder_path is the directory where the file is located
            abs_folder_path = rel_directory.resolve()
            return abs_folder_path, rel_file_path.resolve(), rel_directory, rel_file_path
        else:
            print(f'{self.header} error: file extension not found.')
            return None, None, None, None


    def isOpEligibleToBeExternalized(self, opToTest):
        # Confirm that op can be externalized
        if opToTest.family == 'COMP':
            if "Cannot load external tox from path" in opToTest.scriptErrors():
                return True
            else:
                return opToTest.par.externaltox.eval() == ''
        else:
            # If the sync file is missing, this op should be externalized 
            # (likely resulting from an undo operation)
            if "File not found for sync" in opToTest.warnings():
                return True
            else:
                return opToTest.par.file.eval() == ''


    def getExternalizedOps(self, opFamily):
        # Return list of all COMPs and DATs that have already been externalized
        if opFamily == COMP:
            externalized_ops = self.root.findChildren(
                type=opFamily,
                tags=self.getTags('tox'),
                key=lambda x: (
                    x.par.externaltox.eval() != '' 
                    and not x.path.startswith('/local/') 
                    and x.path != '/local' 
                    and x.type != 'engine'
                    and x.type != 'time'
                    and x.type != 'annotate'
                    and "Cannot load external tox from path" not in (x.scriptErrors() or '')
                )
            )
        else:
            externalized_ops = self.root.findChildren(
                type=opFamily,
                tags=self.getTags('DAT'),
                parName='file',
                key=lambda x: (
                    x.par.file.eval() != ''
                    and not x.path.startswith('/local/')
                    and x.path != '/local'
                    and "File not found for sync" not in (x.warnings() or '')
                )   
            )

        # Sort by path
        sorted_ops = sorted(externalized_ops, key=lambda x: -x.path.count('/'))
        return sorted_ops


    ''' SAVE '''

    def Save(self, opPath):
        # Save the external tox file for COMPs and record the timestamp
        try:
            oper = op(opPath)
            oper.par.enableexternaltox = True
            oper.saveExternalTox()
            # Check if there's an attribute for external timestamp and use it
            if hasattr(op(opPath), 'externalTimeStamp') and oper.externalTimeStamp != 0:
                # Assuming externalTimeStamp is in a format that needs conversion to standard timestamp
                utc_time = datetime.utcfromtimestamp(oper.externalTimeStamp / 10000000 - 11644473600)
                timestamp = utc_time.strftime("%Y-%m-%d %H:%M:%S UTC")
            else:
                # Fallback to the current UTC time if no external timestamp is available
                timestamp = datetime.utcnow().strftime("%Y-%m-%d %H:%M:%S UTC")

            self.Externalizations[opPath, 'timestamp'] = timestamp
            print(f'{self.header} saved {opPath}')
        except Exception as e:
            print(f'{self.header} error: can only save COMPs. Details: {str(e)}')


    def dirtyHandler(self, update):
        # Save and record whether COMPs has been edited
        updates = []
        for oper in self.getExternalizedOps(COMP):
            dirty = oper.dirty
            try:
                self.Externalizations[oper.path, 'dirty'] = dirty
            except:
                #print(f"{self.header} error: The TOX tag for ['{oper.path}'] was added after its external tox parameter was initalized, or the COMP was renamed. Please delete its external tox parameter so it can be properly re-initialized by Embody.")
                pass

            # Update tox if it's source COMP has been edited
            if dirty and update:
                self.Save(oper.path)

        return updates


    def getOpsByTag(self, opFamily):
        # Return OPs by tag
        tags = self.getTags('tox') if opFamily == COMP else self.getTags('DAT')
        return self.root.findChildren(type=opFamily, tags=tags)


    def getOpsByPar(self, opFamily):
        # Return OPs by parameter
        if opFamily == COMP:
            ops_by_par = self.root.findChildren(type=opFamily, key=lambda x: x.par.externaltox.eval() != '' 
                and x.type != 'engine'
                and x.type != 'time'
                and x.type != 'annotate')
        else:
            ops_by_par = self.root.findChildren(type=opFamily, parName='file', key=lambda x: x.par.file.eval() != '', path='^/local/shortcuts')
        return ops_by_par


    def getOpsToExternalize(self, opFamily):
        # Get all ops marked for externalization (with tags on COMP/DAT op types)
        if opFamily == COMP:
            ops_to_externalize = self.root.findChildren(
                type=opFamily,
                tags=self.getTags('tox'),
                parName='externaltox',
                key=lambda x: self.isOpEligibleToBeExternalized(x) and not x.path.startswith('/local/') and x.path != '/local' and x.type != 'engine'
            )
        elif opFamily == DAT:
            ops_to_externalize = self.root.findChildren(
                type=opFamily,
                tags=self.getTags('DAT'),
                parName='file',
                key=lambda x: self.isOpEligibleToBeExternalized(x) and not x.path.startswith('/local/') and x.path != '/local'
            )
        else:
            ops_to_externalize = []
        return ops_to_externalize


    def updateEnableButtonLabel(self, label):
        '''
        Update button label so it only displays 
        'Initialize' for the first init, and then
        'Update' for further updates while running
        '''
        init_button = self.my.op('toolbar/container_left/initialize')
        init_button.par.Buttonofflabel = label
        init_button.par.Buttononlabel = label


    ''' REFRESH '''

    def Refresh(self):
        # Refresh Embody (update dirty state, Lister UI, check for any OP migrations or duplicates)
        self.updateDirtyStates(self.ExternalizationsFolder)
        self.lister.par.Refresh.pulse()
        self.checkOpsForContinuity(self.ExternalizationsFolder)
        self.checkForDuplicates()
        print(self.refreshBar())

        # Check if timeline is paused
        if not me.time.play:
            print(f"- - -\n\n\n{self.header} ALERT! ALERT! YOUR TIMELINE IS PAUSED. RESUME PLAYBACK FOR EMBODY TO FUNCTION\n\n\n- - -")


    def updateDirtyStates(self, externalizationsFolder):
        # Check which COMPs are dirty and mark them in the table
        dirties = self.dirtyHandler(False)
        if dirties:
            plurality = "an" if len(dirties) == 1 else "es"
            print(f'{self.divider}\n{self.header} found {len(dirties)} unsaved tox{plurality}.')


    def checkOpsForContinuity(self, externalizationsFolder):
        # Verify all references are up to date and if not, update them
        for i in range(1, self.Externalizations.numRows):
            try:
                op_path = self.Externalizations[i, 'path'].val
                old_rel_file_path = self.Externalizations[i, 'rel_file_path'].val
                oper = op(op_path)
            except:
                continue

            if oper:
                self.updateOpTimestamp(oper, self.ExternalizationsFolder)
            else:
                self.handleMissingOperator(op_path, old_rel_file_path, self.ExternalizationsFolder)


    def get_local_time_from_utc(self, utc_time):
        # Return local time
        local_now = datetime.now()
        utc_now = datetime.utcnow()
        offset = local_now - utc_now
        local_time = utc_time + offset
        return local_time


    def updateOpTimestamp(self, oper, externalizationsFolder):
        # Update the timestamp in the externalizations tableDAT for a specific OP
        if oper.family == 'COMP':
            save_file_path = self.getOpPaths(oper, self.ExternalizationsFolder)[1]
            # Retrieve the last modified time as UTC directly from the file system
            last_modified = int(Path(save_file_path).stat().st_mtime)
            last_modified_utc = datetime.utcfromtimestamp(last_modified)
            formatted_time = last_modified_utc.strftime("%Y-%m-%d %H:%M:%S UTC")
            self.Externalizations[oper.path, 'timestamp'] = formatted_time
            #print(f"Updated timestamp for {oper.path} to {formatted_time}")


    def handleMissingOperator(self, op_path, old_rel_file_path, externalizationsFolder):
        # Handle operators that might have been renamed or deleted
        renamed = self.checkForRenaming(op_path, old_rel_file_path, self.ExternalizationsFolder)
        if not renamed:
            print(f"{self.header} operator '{op_path}' no longer exists!")
            self.RemoveListerRow(op_path, old_rel_file_path)


    def checkForRenaming(self, op_path, old_rel_file_path, externalizationsFolder):
        # Check if an operator was renamed by comparing paths and parameters
        ops_by_par = self.getOpsByPar(COMP) + self.getOpsByPar(DAT)
        for renamed_op in ops_by_par:
            if self.isRenamedOp(renamed_op, old_rel_file_path):
                self.updateRenamedOp(renamed_op, op_path, old_rel_file_path, self.ExternalizationsFolder)
                return True
        return False


    def isRenamedOp(self, oper, old_rel_file_path):
        # Determine if the operator has been renamed
        file_attr = 'externaltox' if oper.family == 'COMP' else 'file'
        return getattr(oper.par, file_attr) == old_rel_file_path


    def updateRenamedOp(self, oper, old_op_path, old_rel_file_path, externalizationsFolder):
        # Update all details for a renamed operator
        new_paths = self.getOpPaths(oper, self.ExternalizationsFolder)
        self.Externalizations[old_op_path, 'rel_file_path'] = new_paths[3]
        self.Externalizations[old_op_path, 'path'] = oper.path
        self.saveUpdatedExternalFile(oper, new_paths, old_rel_file_path)
        # Update DAT file parameters
        if oper.family == 'DAT':
            oper.par.file = new_paths[3]
        elif oper.family == 'COMP':
            oper.par.externaltox = new_paths[3]

        print(f"{self.header} externalization '{old_rel_file_path}' changed to '{new_paths[3]}'")


    def saveUpdatedExternalFile(self, oper, new_paths, old_rel_file_path):
        # Save out updated external file and clean up old files
        abs_folder_path, save_file_path = new_paths[0], new_paths[1]
        try:
            # Use Pathlib's mkdir method
            abs_folder_path.mkdir(parents=True, exist_ok=True)
            # Save the operator to the new path
            oper.save(str(save_file_path))
            # Clean up the old file
            self.cleanupOldFile(old_rel_file_path)
        except Exception as e:
            print(f"{self.header} error handling file operations for {oper.path}: {e}")


    def cleanupOldFile(self, old_rel_file_path):
        # Attempt to remove the old file and its directory if empty
        old_file_path = Path(old_rel_file_path)
        try:
            if old_file_path.exists():
                old_file_path.unlink()
                print(f"{self.header} removed old file: {old_file_path}")
            else:
                print(f"{self.header} no old file to remove at: {old_file_path}")
        except Exception as e:
            print(f"{self.header} error removing old file '{old_file_path}': {e}")

        # Try to remove the parent directory if it's empty
        try:
            parent_dir = old_file_path.parent
            parent_dir.rmdir()
            print(f"{self.header} folder '{parent_dir}' was empty and has been removed")
        except OSError as e:
            # Directory not empty or other error
            pass
        except Exception as e:
            print(f"{self.header} error removing directory '{parent_dir}': {e}")


    def isInsideClone(self, oper):
        # Traverse up the parent hierarchy
        while oper:
            # Check if operator is a clone
            if oper.family == 'COMP' and oper.par.clone.eval():
                return True
            oper = oper.parent()
        return False


    def isClone(self, oper):
        # Checks if the given operator is a clone by checking its clone parameter
        return oper.family == 'COMP' and oper.par.clone.eval() is not None and oper.par.clone.eval() != ''


    def isReplicant(self, oper):
        # Traverse up the parent hierarchy
        while oper:
            # Check if operator is a replicant
            if oper.family == 'COMP' and oper.replicator:
                return True
            oper = oper.parent()
        return False


    ''' UPDATE '''

    def Update(self):
        '''
        Embody's main enable/update method.
        Check for duplicates, retrieve tags and determine
        added/removed tags, and pass them to the
        addition/subtraction handler methods to process them.
        '''
        if self.my.par.Status == 'Enabled':
            # Check for / fix duplicates
            self.checkForDuplicates()

            # Retrieve all tags, or specific subsets if needed
            all_tags = self.getTags()  # This will get all tags
        
            # Collect operators by their current parameters and intended externalization
            ops_by_par = self.getOpsByPar(COMP) + self.getOpsByPar(DAT)
            ops_to_externalize = self.getOpsToExternalize(COMP) + self.getOpsToExternalize(DAT)
            externalized_ops = self.getExternalizedOps(COMP) + self.getExternalizedOps(DAT)

            # Filtering operations to only include relevant operators
            additions = [
                oper for oper in ops_to_externalize
                if oper not in externalized_ops
                and set(all_tags).intersection(oper.tags)
                and self.isOpProcessable(oper)
            ]
            subtractions = [
                oper for oper in ops_by_par
                if oper not in externalized_ops
                and not oper.warnings()
                and not oper.scriptErrors()
                and set(all_tags).intersection(oper.tags)
                and self.isOpProcessable(oper)
            ]
            regular_additions = []

            # Sort additions to ensure a specific order if needed
            additions.sort(key=lambda x: (self.Externalizations.path in x.path, x.path), reverse=True)

            # Process additions
            for oper in additions:
                self.handleAddition(oper)
                regular_additions.append(oper)

            # Process subtractions
            for oper in subtractions:
                self.handleSubtraction(oper)

            # Handle potentially dirty COMPs to update them
            dirties = self.dirtyHandler(True)

            # Reporting results
            plural = any(len(lst) > 1 for lst in [dirties, regular_additions, subtractions])
            self.printResults(dirties, regular_additions, subtractions, plural)

            # Refresh display
            run(f"op('{self.my}').par.Refresh.pulse()", delayFrames=1)
            self.updateEnableButtonLabel('Update')


    def checkForDuplicates(self):
        # Check for duplicate OPs, usually those inside clones and process them
        def is_inside_clone(op):
            while op:
                if op.family == 'COMP':
                    try:
                        if op.par.clone and op.par.clone.eval():
                            return True
                    except:
                        if op.par.clone.expr:
                            return True
                op = op.parent()
            return False

        # Collect all existing external tox paths
        external_paths = {}
        duplicate_ops = []

        for op in self.root.findChildren(type=COMP, parName='externaltox'):
            if is_inside_clone(op):
                continue  # Skip operators inside clone COMPs
            path = op.par.externaltox.eval()
            if path:
                if path in external_paths:
                    duplicate_ops.append((op, external_paths[path]))
                else:
                    external_paths[path] = op

        for op in self.root.findChildren(type=DAT, parName='file'):
            if is_inside_clone(op):
                continue  # Skip operators inside clone COMPs
            path = op.par.file.eval()
            if path:
                if path in external_paths:
                    duplicate_ops.append((op, external_paths[path]))
                else:
                    external_paths[path] = op

        # Process duplicates
        for new_op, existing_op in duplicate_ops:
            op_path = new_op.path
            op_type = new_op.family
            message = f"Duplicate external file path detected for {op_type} '{op_path}'. Add to Embody? Warning: This will reset the externaltox/file path."
            choice = ui.messageBox('Duplicate External Path Detected', message, buttons=['No', 'Yes'])

            if choice == 1:
                if op_type == 'COMP':
                    new_op.par.externaltox = ''
                    self.Update()
                else:
                    new_op.par.file = ''
                    self.Update()
                print(f"{self.header} renamed {op_path} to {new_op.name}")


    def handleAddition(self, oper):
        # Process COMPs/DATs added to Embody for externalization
        abs_folder_path, save_file_path, rel_directory, rel_file_path = self.getOpPaths(oper, self.my.par.Folder.val)
        try:
            os.makedirs(abs_folder_path)
        except FileExistsError:
            pass

        if oper.family == 'COMP':
            oper.par.externaltox = rel_file_path
            oper.par.externaltox.readOnly = True
            oper.par.enableexternaltox = True
            oper.save(save_file_path)
            dirty = oper.dirty
            if hasattr(oper, 'externalTimeStamp'):  # Ensuring attribute exists
                external_time_utc = datetime.utcfromtimestamp(oper.externalTimeStamp / 10000000 - 11644473600)  # Convert Windows file time to UTC datetime
                local_time = self.get_local_time_from_utc(external_time_utc)
                timestamp = local_time.strftime("%Y-%m-%d %H:%M:%S UTC")
            else:
                timestamp = self.get_local_time_from_utc(datetime.utcnow()).strftime("%Y-%m-%d %H:%M:%S UTC")  # Fallback to current time if not available

            if "Cannot load external tox from path" in oper.scriptErrors():
                oper.allowCooking = False
                run(f"op('{oper}').allowCooking = True", delayFrames = 1)

        elif oper.family == 'DAT':
            oper.par.file = str(rel_file_path)
            oper.par.syncfile = True
            run(f"op('{oper}').par.syncfile = False", delayFrames = 1)
            run(f"op('{oper}').par.syncfile = True", delayFrames = 2)
            oper.par.file.readOnly = True
            # Save the DAT content to the file
            oper.save(str(save_file_path))
            dirty = ''
            timestamp = datetime.utcnow().strftime("%Y-%m-%d %H:%M:%S UTC")

        # Extract relevant data to be added, excluding the timestamp
        new_row_data = [oper.path, oper.type, rel_file_path, dirty]

        # Iterate through the existing rows in the table to check for duplicates
        row_exists = False
        for row in range(1, self.Externalizations.numRows):
            existing_row_data = [
                self.Externalizations[row, 0],  # path
                self.Externalizations[row, 1],  # type
                self.Externalizations[row, 2],  # rel_file_path
                self.Externalizations[row, 4]   # dirty
            ]
            if existing_row_data == new_row_data:
                row_exists = True
                break

        # Add row only if it doesn't exist
        if not row_exists:
            self.Externalizations.appendRow([oper.path, oper.type, rel_file_path, timestamp, dirty])

        print(f"{self.header} added '{oper.path}'")


    def handleSpecialCaseAddition(self, oper):
        # Manage special cases
        # Example action for special case: Log and skip usual processing
        #print(f"Special handling for: {oper.path}")
        # Add more actions as necessary for special cases
        pass


    def handleSubtraction(self, oper):
        # Process COMPs/DATs removed from Embody
        self.Externalizations.deleteRow(oper.path)
        if oper.family == 'COMP':
            oper.par.externaltox.readOnly = False
        elif oper.family == 'DAT':
            oper.par.file.readOnly = False
        print(f"{self.header} removed '{oper.path}'")


    def printResults(self, dirties, additions, subtractions, plural):
        # Print results
        print(self.divider)
        if dirties:
            print(f'{self.header} saved {dirties} tox{"es" if plural else ""}')
        if additions:
            print(f'{self.header} added {len(additions)} operator{"s" if plural else ""} in total')
        if subtractions:
            print(f'{self.header} removed {len(subtractions)} operator{"s" if plural else ""} in total')


    def getProjectFolder(self):
        # Fetch the TouchDesigner project folder (for file operations)
        if self.my.par.Folder.mode == ParMode.EXPRESSION:
            externalizations_folder = self.my.par.Folder.eval()
        else:
            externalizations_folder = project.folder + '/' + self.my.par.Folder
        return externalizations_folder


    def UpdateHandler(self):
        # Re-init all marked externalizations
        # If already init'd, this functions as a normal Update
        if self.my.par.Status == 'Disabled':
            print(f"{self.divider}\n{self.header} enabled\n{self.divider}")
            self.my.par.Status = 'Enabled'

            # Create Embody folder if it doesn't exist
            externalizations_folder = self.getProjectFolder()
            try:
                os.mkdir(externalizations_folder)
                print(f"{self.header} created externalization folder '{externalizations_folder}'")
            except FileExistsError:
                pass

            # Refresh hack to get the folderDAT operational again on a new instance of Embody
            if len(self.folder_dat.warnings()) > 0:
                run(f"op('{self.folder_dat}').cook(force=True)", delayFrames = 10)
                run(f"op('{self.folder_dat}').par.active = 0", delayFrames = 20)
                run(f"op('{self.folder_dat}').par.active = 1", delayFrames = 30)

        run(f"op('{self.my}').Update()", delayFrames = 1)
        

    def Manager(self, action):
        # Open the viewer and refresh for latest status report
        win = self.my.op('window_manager')
        if action == 'open':
            win.par.winopen.pulse()
            self.Refresh()
        
        # Close it
        elif action == 'close':
            win.par.winclose.pulse()


    ''' TAGGING '''

    def getTagColorForOperator(self, oper, tag):
        """
        Return the color for the tag if it can be applied to the operator, otherwise None
        """
        if oper.family == 'COMP':
            if tag == self.my.par.Toxtag.val:
                return (self.my.par.Toxtagcolorr, self.my.par.Toxtagcolorg, self.my.par.Toxtagcolorb)
            else:
                print(f"{self.header} error: TOX tags can only be applied to COMP operators.")
                return None
        elif oper.family == 'DAT':
            if tag in self.getTags('DAT') and oper.type in self.supported_dat_oper_types:
                return (self.my.par.Dattagcolorr, self.my.par.Dattagcolorg, self.my.par.Dattagcolorb)
            else:
                print(f"{self.header} error: DAT tags can only be applied to text/table/*execDAT operators")
                return None
        else:
            print(f"{self.header} error: Embody tags can only be applied to COMPs or text/table/*execDAT operators")
            return None


    def applyTagToOperator(self, oper, tag):
        # Apply a tag/color to an OP
        color = self.getTagColorForOperator(oper, tag)
        if color is None:
            return False

        if oper.family == 'COMP':
            if oper.par.externaltox and oper.par.externaltox.eval() and tag not in oper.tags:
                print(f"{self.header} warning: operator '{oper.path}' has an existing externaltox parameter. remove the externaltox to add to Embody")
                return False

        if tag not in oper.tags:
            oper.tags.add(tag)
            oper.color = color
            print(f"{self.header} tag '{tag}' applied to '{oper.path}'")
        else:
            # Tag already present
            pass
        return True


    def toggleTagOnOperator(self, oper, tag):
        # Process the addition or removal of a tag for an OP.
        #print('toggle tag ' + oper + 'tag: ' + tag)
        color = self.getTagColorForOperator(oper, tag)
        if color is None:
            return False

        if oper.family == 'COMP' and oper.par.externaltox and oper.par.externaltox.eval() and tag not in oper.tags:
            ui.messageBox('Embody Warning', f"The operator '{oper.path}' already has an external tox file linked. Please remove the custom externaltox parameter to add this to Embody.", buttons=['Ok'])
            print(f"{self.header} warning: operator '{oper.path}' has an existing externaltox parameter. Remove the externaltox to add to Embody.")
            return False

        if tag not in oper.tags:
            # Apply the tag
            oper.tags.add(tag)
            oper.color = color
            #print(f"{self.header} tag '{tag}' applied to '{oper.path}'.")
        else:
            # Remove the tag
            oper.tags.remove(tag)
            self.resetOpColor(oper)
            # Remove from externalizations
            rel_file_path = oper.par.externaltox.eval() if oper.family == 'COMP' else oper.par.file.eval()
            self.RemoveListerRow(oper.path, rel_file_path)
            # Clear external parameters
            if oper.family == 'COMP':
                oper.par.externaltox = ''
                oper.par.externaltox.readOnly = False
                #print(f"{self.header} externaltox parameter cleared for '{oper.path}' as the tag was removed.")
            elif oper.family == 'DAT':
                oper.par.file = ''
                oper.par.file.readOnly = False
                #print(f"{self.header} file parameter cleared for '{oper.path}' as the tag was removed.")
            #print(f"{self.header} tag '{tag}' removed from '{oper.path}'.")
        return True


    def getTags(self, selection=False):
        # Return a list of all tag pars from Embody custom pars
        tags = [par.val for par in self.my.pars('*tag')]
        if selection == 'tox':
            tags = [tag for tag in tags if tag == self.my.par.Toxtag.val]
        elif selection == 'DAT':
            tags = [tag for tag in tags if tag != self.my.par.Toxtag.val]
        return tags


    def TagExiter(self):
        # Close the Tagger UI window
        self.tagging_menu_window.par.winclose.pulse()
        #self.mouse.par.active = 0


    def TagSetter(self, tag):
        # Set the tag from the Tagger UI
        #print('tag setter ' + tag)
        for oper in self.SelectedOps:
            success = self.toggleTagOnOperator(oper, tag)
            if not success:
                continue  # Skip to next operator
        # Auto-update
        self.UpdateHandler()
        #self.mouse.par.active = 0


    def alternateColor(self, color):
        return f'{color} if me.digits % 2 else {color} - 0.05'


    def SetupTagger(self):
        # Reset button colors
        params = self.tagger.op('tags')
        for i in range(1, params.numRows):
            button = self.tagger.op(f'button{i}')
            if button:
                button.par.colorr = self.my.par.Taggingmenucolorr
                button.par.colorg.expr = self.alternateColor(parent.Embody.par.Taggingmenucolorg)
                button.par.colorb = self.my.par.Taggingmenucolorb

        for oper in self.SelectedOps:
            # Loop over all parameters (tags)
            for i in range(1, params.numRows):
                button = self.tagger.op(f'button{i}')
                if len(oper.tags) > 0:
                    for tag in oper.tags:


                        # Mark active tags in menu
                        if tag == params[i, 'value'].val:
                            button.par.colorr = self.my.par.Toxtagcolorr if oper.family == 'COMP' else self.my.par.Dattagcolorr
                            button.par.colorg.expr = self.alternateColor(self.my.par.Toxtagcolorg) if oper.family == 'COMP' else self.alternateColor(self.my.par.Dattagcolorg)
                            button.par.colorb = self.my.par.Toxtagcolorb if oper.family == 'COMP' else self.my.par.Dattagcolorb


    def TagGetter(self):
        # Get the tags of the currently selected operator(s) and
        # Display them in the tagging menu
        params = self.tagger.op('tags')
        switch = self.tagger.op('switch_family')
        selected_op = op(f"{var('OP_SELECT')}")
        if not selected_op:
            print(f"{self.header} no supported operator is selected")
            return
        current_network = selected_op.parent()
        selected_ops = current_network.selectedChildren
        self.SelectedOps = []

        show_dats = False
        show_toxes = False
        for oper in selected_ops:
            # Check if the operator is an unsupported type (engineCOMP)
            if oper.type == 'engine':
                ui.messageBox('Embody Error', f"Operator '{oper.path}' is of type '{oper.type}', which is not supported for tagging.", buttons=['Ok'])
                continue  # Skip this operator

            # Check if the operator is a replicant or a clone
            if self.isReplicant(oper) or self.isClone(oper) or self.isInsideClone(oper):
                ui.messageBox('Embody Warning', f"Operator '{oper.path}' is either a replicant or a clone and cannot be externalized.\nNo tags will be applied to it.", buttons=['Ok'])
                continue  # Skip this operator

            # Add to the list of eligible operators to tag
            self.SelectedOps.append(oper)

            # Display only relevant tags (tox or DAT)
            if oper.type in self.supported_dat_oper_types:
                show_dats = True
            elif oper.family == 'COMP':
                show_toxes = True
            else:
                ui.messageBox('Embody Error', 'Embody Tags can only be applied to COMPs or text/table/*execDAT operators.', buttons=['Ok'])
                return

        # Display only relevant tags (tox or DAT)
        if not show_dats:
            switch.par.index = 2
        elif not show_toxes:
            switch.par.index = 1
        elif show_toxes and show_dats:
            switch.par.index = 0

        # Setup tagger only for eligible operators
        if self.SelectedOps:
            run(f"op('{self.my}').SetupTagger()", delayFrames=1)
            run(f"op('{self.tagging_menu_window}').par.winopen.pulse()", delayFrames=2)
            #self.mouse.par.active = 1


    ''' EXTERNALIZE FULL PROJECT '''

    def ExternalizeProject(self):
        # Prompt user for confirmation
        choice = ui.messageBox(
            'Embody',
            'This process will add every compatible COMP and DAT to Embody from your project.\nDerivative Palette components, clones and replicants will be ignored. \nDo you want to proceed?',
            buttons=['Cancel', 'Confirm']
        )
        if choice == 0:
            return  # User selected 'Cancel', so do nothing

        # Find all COMPs whose clone parameter contains 'sys'
        sys_comps = self.root.findChildren(
            type=COMP,
            parName='clone',
            key=lambda x: 'TDTox' in (str(x.par.clone.expr) or '') or 'TDBasicWidgets' in (str(x.par.clone.expr) or '')
            )

        # Build a set of paths to exclude (these COMPs and their descendants)
        paths_to_exclude = set()
        for sys_comp in sys_comps:
            paths_to_exclude.add(sys_comp.path)
            # Add all descendants
            descendants = sys_comp.findChildren()
            for desc in descendants:
                paths_to_exclude.add(desc.path)

        # Find all compatible DATs and COMPs
        compatible_dats = self.root.findChildren(type=DAT, parName='file')
        compatible_comps = self.root.findChildren(type=COMP, parName='externaltox')
        
        # For DATs
        for oper in compatible_dats:
            # Skip operators that are in paths to exclude
            if oper.path in paths_to_exclude:
                continue
            # Skip DATs inside clones or replicators
            if self.isReplicant(oper) or self.isInsideClone(oper):
                continue
            # Exclude operators under '/local/'
            if oper.path.startswith('/local/') or oper.path == '/local':
                continue

            # Apply tags to certain DAT types
            if oper.type in self.supported_dat_oper_types:
                tag_param = self.dat_type_to_tag.get(oper.type, 'Pytag')

                # Special handling for TextDATs with extensions and language
                if oper.type == 'text':
                    extension = oper.par.extension.eval() if hasattr(oper.par, 'extension') else ''
                    language = oper.par.language.eval() if hasattr(oper.par, 'language') else ''

                    # Check language first, then extension
                    if language in self.extension_language_to_tag:
                        tag_param = self.extension_language_to_tag[language]
                    elif extension in self.extension_language_to_tag:
                        tag_param = self.extension_language_to_tag[extension]

                tag_value = getattr(self.my.par, tag_param).eval()
                self.ApplyTagToOperator(oper, tag_value)

            else:
                continue  # Skip other DAT types
        
        # For COMPs

        # Get the COMP tag
        comp_tag = self.my.par.Toxtag.val  # Should be the TOX tag
        
        for oper in compatible_comps:
            # Skip operators that are in paths to exclude
            if oper.path in paths_to_exclude:
                continue
            # Skip COMPs inside clones or replicators
            if self.isReplicant(oper) or self.isInsideClone(oper):
                continue
            # Exclude operators under '/local/'
            if oper.path.startswith('/local/') or oper.path == '/local':
                continue
            # Apply the TOX tag
            self.ApplyTagToOperator(oper, comp_tag)

        # Update Embody
        self.UpdateHandler()


    def ApplyTagToOperator(self, oper, tag):
        # Apply tag to an operator
        success = self.applyTagToOperator(oper, tag)
        if not success:
            print(f"{self.header} failed to apply tag '{tag}' to '{oper.path}'.")


    ''' UTILITIES '''

    def isOpProcessable(self, oper):
        # Handle replications, clones and ignore the /local directory
        return (
            not self.isReplicant(oper) and
            not self.isInsideClone(oper) and
            not oper.path.startswith('/local/') and
            oper.path != '/local' and
            oper.type != 'engine' and
            oper.type != 'time' and
            oper.type != 'annotate'
        )


    def RemoveListerRow(self, op_path, rel_file_path):
        # Remove the externalized op from the Lister COMP
        #print('remove lister row ' + rel_file_path)
        try:
            oper = op(op_path)
            if oper:
                # Remove tags and reset parameters if the operator still exists
                tags = [tag for tag in self.getTags() if tag in oper.tags]
                for tag in tags:
                    oper.tags.remove(tag)
                if oper.family == 'COMP':
                    oper.par.externaltox = ''
                    oper.par.externaltox.readOnly = False
                    oper.cook(force=True)
                elif oper.family == 'DAT':
                    oper.par.syncfile = False
                    oper.par.file = ''
                    oper.par.file.readOnly = False
                    oper.cook(force=True)
                self.resetOpColor(oper)
        except Exception as e:
            print(f"{self.header} error handling operator parameters for '{op_path}': {e}")

        # Attempt to remove the external file after a slight delay
        if rel_file_path:
            full_file_path = Path(project.folder) / rel_file_path
            full_file_path = full_file_path.resolve()

            def delete_file():
                try:
                    if full_file_path.is_file():
                        full_file_path.unlink()
                        print(f"{self.header} removed external file for '{op_path}': {rel_file_path}")
                    else:
                        print(f"{self.header} no external file found to remove for '{op_path}': {rel_file_path}")
                except Exception as e:
                    print(f"{self.header} error removing file '{rel_file_path}': {e}")

            # Delay the deletion to ensure the file handle is released
            run(delete_file, delayFrames=5)
        else:
            # rel_file_path is empty; no file to remove
            pass

        # Remove the row from the externalizations table
        try:
            self.Externalizations.deleteRow(op_path)
            print(f"{self.header} removed '{op_path}' from table")
        except Exception as e:
            print(f"{self.header} error removing '{op_path}' from table: {e}")


    def getSaveFolder(self):
        # Return the Save folder par
        if self.my.par.Folder.expr:
            folder = self.my.par.Folder.eval()
        else:
            folder = project.folder + '/' + self.my.par.Folder

        return folder


    def OpenSaveFolder(self):
        # Get the save folder path using pathlib for cross-platform compatibility
        save_folder = Path(self.getSaveFolder()).resolve()
        save_folder_str = str(save_folder)

        if sys.platform.startswith('darwin'):
            # macOS: Use 'open' to open the folder in Finder
            subprocess.call(['open', save_folder_str])
        elif sys.platform.startswith('win'):
            # Windows: Use os.startfile to open the folder in Explorer
            os.startfile(save_folder_str)


    def OpenSaveFile(self, rel_file_path):
        # Build the full path using pathlib for cross-platform compatibility
        filepath = Path(project.folder) / rel_file_path

        # Ensure the path is absolute and resolve any symlinks
        filepath = filepath.resolve()

        # Convert the path to a string
        filepath_str = str(filepath)

        if sys.platform.startswith('darwin'):
            # macOS: Use 'open -R' to reveal the file in Finder
            subprocess.call(['open', '-R', filepath_str])
        elif sys.platform.startswith('win'):
            # Windows: Use 'explorer /select,' to open Explorer and select the file
            # Replace forward slashes with backslashes in the path
            filepath_str = filepath_str.replace('/', '\\')
            subprocess.call(['explorer', '/select,', filepath_str])


    def OpenTable(self):
        # Open the externalizations tableDAT viewer
        self.Externalizations.openViewer()


    def refreshBar(self):
        # Get current timestamp
        timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")

        # Return formatted string with timestamp
        return f"{self.header} refreshed at {timestamp}\n{self.divider}"


    def deleteEmptyDirectories(self, path):
        """ Recursively delete empty directories until none are left. """
        empty_dir_found = True
        iteration_count = 0
        while empty_dir_found and iteration_count < 10:  # Limit iterations to avoid infinite loops in case of errors
            empty_dir_found = False
            iteration_count += 1
            for root, dirs, files in os.walk(path, topdown=False):
                for dir in dirs:
                    dir_path = os.path.join(root, dir)
                    if not os.listdir(dir_path):  # Check if the directory is empty
                        try:
                            os.rmdir(dir_path)
                            print(f"{self.header} deleted empty directory: {dir_path}")
                            empty_dir_found = True  # Set flag to True if a directory was deleted
                        except OSError as e:
                            # Logging the error and continuing
                            print(f"{self.header} error deleting directory: {dir_path} [{e}]")

        if empty_dir_found:
            print(f"{self.header} Warning: Could not delete some empty directories after {iteration_count} iterations.")


    def deleteFile(self, oper, externalizationsFolder):
        # Remove externalized file from file system
        abs_folder_path, save_file_path, rel_directory, rel_file_path = self.getOpPaths(oper, externalizationsFolder)
        if save_file_path is None:
            return  # Can't proceed without a valid path

        save_file = save_file_path.resolve()
        try:
            if save_file.exists():
                save_file.unlink()
                print(f"{self.header} deleted file: {save_file}")
                # Attempt to remove the file directory (if empty)
                try:
                    abs_folder_path.rmdir()
                except OSError:
                    # Directory not empty
                    pass
            else:
                # File does not exist
                pass

        except FileNotFoundError:
            print(f"{self.header} FileNotFoundError: {save_file}")
        except PermissionError:
            # Insufficient permissions to delete the file
            #print('perm')
            pass
        except Exception as e:
            # Handle other exceptions
            #print(e)
            pass


    def resetOpColor(self, oper):
        # Reset operator color to default value
        oper.color = (0.55, 0.55, 0.55)


    def getMouseCoords(self):
        # Return current mouse coordinates
        return self.mouse['tx'].eval(), self.mouse['ty'].eval()


    def SetMouseCoords(self, reset):
        # Apply mouse coordinates based on reset input
        tx, ty = self.getMouseCoords()
        coords = self.my.op('constant1')
        coords.par.value0 = tx
        coords.par.value1 = ty
        self.my.op('math_tx').par.postoff = 0.002 if not reset else 0


    def WiggleMouseCoords(self):
        # "Wiggle" the mouse to ensure the correct OP is selected for the Tagger menu
        self.SetMouseCoords(0)
        run(f"op('{self.my}').SetMouseCoords(1)", delayFrames = 1)
        #run(f"op('{self.mouse}').par.active = 0", delayFrames = 4)


    def MissingExternalizationsPar(self):
        print(f"{self.header} Embody is missing an Externalization tableDAT, which is required to function. Please add one to the Externalizations parameter.")


