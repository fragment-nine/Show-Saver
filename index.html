<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Sync Measurement App</title>
<style>
  body { margin: 0; font-family: Arial, sans-serif; background-color: #222; color: #fff; overflow: hidden; }
  #videoContainer {
    position: relative;
    width: 100%;
    height: calc(100vh - 250px); /* Adjust for control panel height */
    background-color: #000;
  }
  #videoElement {
    width: 100%;
    height: 100%;
    object-fit: cover;
  }
  #overlay {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
  }
  #crosshair {
    position: absolute;
    top: 50%;
    left: 50%;
    width: 40px;
    height: 40px;
    margin-left: -20px;
    margin-top: -20px;
    border: 2px solid red;
    border-radius: 50%;
    transition: border-color 0.2s;
  }
  #controls {
    position: fixed;
    bottom: 0;
    width: 100%;
    background-color: #111;
    padding: 10px;
    box-sizing: border-box;
  }
  #deltaDisplay {
    font-size: 24px;
    margin-top: 10px;
    text-align: center;
  }
  #startButton {
    padding: 10px 20px;
    font-size: 18px;
    width: 100%;
  }
  #sliders {
    display: flex;
    justify-content: space-around;
    margin-top: 10px;
  }
  .slider-container {
    flex: 1;
    margin: 0 5px;
  }
  .slider-container label {
    display: block;
    text-align: center;
  }
  .slider-container input[type="range"] {
    width: 100%;
  }
  #meters {
    display: flex;
    justify-content: space-around;
    margin-top: 10px;
  }
  .meter-container {
    flex: 1;
    margin: 0 5px;
    text-align: center;
  }
  .meter {
    width: 100%;
    height: 20px;
    background-color: #555;
    position: relative;
    margin-top: 5px;
  }
  .meter-fill {
    height: 100%;
    background-color: lime;
    width: 0%;
  }
  .meter-threshold {
    position: absolute;
    top: -2px;
    width: 2px;
    height: 24px;
    background-color: red;
  }
  #logContainer {
    width: 100%;
    height: 200px;
    background-color: #333;
    color: #fff;
    padding: 10px;
    box-sizing: border-box;
    overflow-y: auto;
    margin-top: 10px;
  }
  #logContent {
    font-size: 14px;
    white-space: pre-wrap;
  }
  canvas { display: none; }
</style>
</head>
<body>

<div id="videoContainer">
  <video id="videoElement" autoplay playsinline></video>
  <canvas id="videoCanvas"></canvas>
  <div id="overlay">
    <div id="crosshair"></div>
  </div>
</div>

<div id="controls">
  <button id="startButton">Start Measurement</button>
  <div id="sliders">
    <div class="slider-container">
      <label for="brightnessThreshold">Brightness Threshold: <span id="brightnessValue">250</span></label>
      <input type="range" id="brightnessThreshold" min="0" max="255" value="250">
    </div>
    <div class="slider-container">
      <label for="volumeThreshold">Volume Threshold: <span id="volumeValue">15</span></label>
      <input type="range" id="volumeThreshold" min="0" max="100" value="15">
    </div>
  </div>
  <div id="meters">
    <div class="meter-container">
      <div>Brightness Level</div>
      <div class="meter" id="brightnessMeter">
        <div class="meter-fill" id="brightnessFill"></div>
        <div class="meter-threshold" id="brightnessMeterThreshold"></div>
      </div>
    </div>
    <div class="meter-container">
      <div>Volume Level</div>
      <div class="meter" id="volumeMeter">
        <div class="meter-fill" id="volumeFill"></div>
        <div class="meter-threshold" id="volumeMeterThreshold"></div>
      </div>
    </div>
  </div>
  <div id="deltaDisplay">Delta: -- ms</div>
  <div id="logContainer">
    <h2>Logs</h2>
    <div id="logContent"></div>
  </div>
</div>

<script>
let video = document.getElementById('videoElement');
let canvas = document.getElementById('videoCanvas');
let deltaDisplay = document.getElementById('deltaDisplay');
let startButton = document.getElementById('startButton');
let crosshair = document.getElementById('crosshair');

let brightnessThresholdInput = document.getElementById('brightnessThreshold');
let volumeThresholdInput = document.getElementById('volumeThreshold');
let brightnessValueDisplay = document.getElementById('brightnessValue');
let volumeValueDisplay = document.getElementById('volumeValue');

let brightnessMeterFill = document.getElementById('brightnessFill');
let volumeMeterFill = document.getElementById('volumeFill');
let brightnessMeterThreshold = document.getElementById('brightnessMeterThreshold');
let volumeMeterThreshold = document.getElementById('volumeMeterThreshold');

let logContent = document.getElementById('logContent');

let videoStream;
let audioStream;
let audioContext;
let analyser;
let dataArray;
let audioInitialized = false;

let lastFlashTime = null;
let lastBeepTime = null;

let running = false;

let brightnessThreshold = parseInt(brightnessThresholdInput.value);
let volumeThreshold = parseInt(volumeThresholdInput.value);

let lastBrightnessOverThreshold = false;
let lastVolumeOverThreshold = false;

function log(message) {
  console.log(message); // Log to browser console
  let logEntry = document.createElement('div');
  logEntry.textContent = message;
  logContent.appendChild(logEntry);
  logContent.scrollTop = logContent.scrollHeight; // Scroll to the latest log entry
}

startButton.addEventListener('click', async () => {
  if (!running) {
    startButton.disabled = true;
    await startApp();
    startButton.textContent = 'Stop Measurement';
    startButton.disabled = false;
    running = true;
  } else {
    stopApp();
    startButton.textContent = 'Start Measurement';
    deltaDisplay.textContent = 'Delta: -- ms';
    running = false;
  }
});

brightnessThresholdInput.addEventListener('input', () => {
  brightnessThreshold = parseInt(brightnessThresholdInput.value);
  brightnessValueDisplay.textContent = brightnessThreshold;
  updateBrightnessThresholdMeter();
  log(`Brightness threshold updated to ${brightnessThreshold}`);
});

volumeThresholdInput.addEventListener('input', () => {
  volumeThreshold = parseInt(volumeThresholdInput.value);
  volumeValueDisplay.textContent = volumeThreshold;
  updateVolumeThresholdMeter();
  log(`Volume threshold updated to ${volumeThreshold}`);
});

function updateBrightnessThresholdMeter() {
  let meterWidth = document.getElementById('brightnessMeter').offsetWidth;
  brightnessMeterThreshold.style.left = (brightnessThreshold / 255) * meterWidth - 1 + 'px';
}

function updateVolumeThresholdMeter() {
  let meterWidth = document.getElementById('volumeMeter').offsetWidth;
  volumeMeterThreshold.style.left = (volumeThreshold / 100) * meterWidth - 1 + 'px';
}

async function startApp() {
  try {
    // Get user media
    videoStream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' }, audio: false });
    video.srcObject = videoStream;
    video.muted = true; // Mute the video element to prevent audio playback
    log('Video stream started.');

    // Setup audio processing
    if (!audioInitialized) {
      await setupAudioProcessing();
      audioInitialized = true;
    }

    processAudioFrame();
    log('Audio processing started.');

    processVideoFrame();
  } catch (err) {
    log(`Error accessing media devices: ${err.message}`);
    alert('Error accessing camera or microphone: ' + err.message);
  }
}

function stopApp() {
  // Stop video stream
  if (videoStream) {
    videoStream.getTracks().forEach(track => track.stop());
    log('Video stream stopped.');
  }
  // Stop audio stream
  if (audioStream) {
    audioStream.getTracks().forEach(track => track.stop());
    log('Audio stream stopped.');
  }
  // Stop audio context
  if (audioContext) {
    audioContext.close();
    log('Audio context closed.');
    audioInitialized = false;
  }
}

async function setupAudioProcessing() {
  audioContext = new (window.AudioContext || window.webkitAudioContext)();
  await audioContext.resume();
  log(`AudioContext created and resumed. State: ${audioContext.state}`);

  const devices = await navigator.mediaDevices.enumerateDevices();
  const audioDevices = devices.filter(device => device.kind === 'audioinput');
  
  log('Available audio input devices:');
  audioDevices.forEach(device => log(`Device label: ${device.label}, Device ID: ${device.deviceId}`));

  audioStream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
  log('Microphone access granted.');

  let audioTracks = audioStream.getAudioTracks();
  if (audioTracks.length > 0) {
    log(`Using audio device: ${audioTracks[0].label}`);
  }

  let source = audioContext.createMediaStreamSource(audioStream);
  analyser = audioContext.createAnalyser();
  analyser.fftSize = 256;
  let bufferLength = analyser.frequencyBinCount;
  dataArray = new Uint8Array(bufferLength);
  source.connect(analyser);
  log('Audio nodes connected.');
}

function processVideoFrame() {
  if (!running) return;

  let ctx = canvas.getContext('2d');
  if (video.videoWidth === 0 || video.videoHeight === 0) {
    requestAnimationFrame(processVideoFrame);
    return;
  }

  canvas.width = video.videoWidth;
  canvas.height = video.videoHeight;
  ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

  let centerX = canvas.width / 2;
  let centerY = canvas.height / 2;
  let sampleSize = 10;
  let imageData = ctx.getImageData(centerX - sampleSize / 2, centerY - sampleSize / 2, sampleSize, sampleSize);
  let pixels = imageData.data;
  let sum = 0;
  for (let i = 0; i < pixels.length; i += 4) {
    let brightness = (pixels[i] + pixels[i + 1] + pixels[i + 2]) / 3;
    sum += brightness;
  }
  let avgBrightness = sum / (pixels.length / 4);

  let brightnessPercent = (avgBrightness / 255) * 100;
  brightnessMeterFill.style.width = brightnessPercent + '%';
  log(`Brightness level: ${brightnessPercent.toFixed(2)}%`);

  let brightnessOverThreshold = avgBrightness > brightnessThreshold;
  if (brightnessOverThreshold && !lastBrightnessOverThreshold) {
    let currentTime = performance.now();
    lastFlashTime = currentTime;
    indicateFlashDetection();
    calculateDelta();
    log('Flash detected.');
  }
  lastBrightnessOverThreshold = brightnessOverThreshold;

  requestAnimationFrame(processVideoFrame);
}

function processAudioFrame() {
  if (!running) return;

  analyser.getByteFrequencyData(dataArray);

  let sum = 0;
  for (let i = 0; i < dataArray.length; i++) {
    sum += dataArray[i];
  }
  let avgVolume = sum / dataArray.length;

  let volumePercent = (avgVolume / 255) * 100;
  volumeMeterFill.style.width = volumePercent + '%';
  log(`Volume level: ${volumePercent.toFixed(2)}%`);

  let volumeOverThreshold = avgVolume > volumeThreshold;
  if (volumeOverThreshold && !lastVolumeOverThreshold) {
    let currentTime = performance.now();
    lastBeepTime = currentTime;
    indicateBeepDetection();
    calculateDelta();
    log('Beep detected.');
  }
  lastVolumeOverThreshold = volumeOverThreshold;

  requestAnimationFrame(processAudioFrame);
}

function calculateDelta() {
  if (lastFlashTime && lastBeepTime) {
    let delta = lastFlashTime - lastBeepTime;
    deltaDisplay.textContent = 'Delta: ' + delta.toFixed(2) + ' ms';
    log(`Delta calculated: ${delta.toFixed(2)} ms`);
  }
}

function indicateFlashDetection() {
  crosshair.style.borderColor = 'lime';
  setTimeout(() => {
    crosshair.style.borderColor = 'red';
  }, 200);
}

function indicateBeepDetection() {
  deltaDisplay.style.color = 'yellow';
  setTimeout(() => {
    deltaDisplay.style.color = '#fff';
  }, 200);
}

updateBrightnessThresholdMeter();
updateVolumeThresholdMeter();

</script>

</body>
</html>