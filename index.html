<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Sync Measurement App</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    body { margin: 0; font-family: Arial, sans-serif; background-color: #222; color: #fff; overflow: hidden; }
    #videoContainer {
      position: relative;
      width: 100%;
      height: calc(100vh - 350px); /* Adjust for control panel and waveform canvas height */
      background-color: #000;
    }
    #videoElement {
      width: 100%;
      height: 100%;
      object-fit: cover;
    }
    #overlay {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
    }
    #crosshair {
      position: absolute;
      top: 50%;
      left: 50%;
      width: 40px;
      height: 40px;
      margin-left: -20px;
      margin-top: -20px;
      border: 2px solid red;
      border-radius: 50%;
      transition: border-color 0.2s;
    }
    #controls {
      position: fixed;
      bottom: 0;
      width: 100%;
      background-color: #111;
      padding: 10px;
      box-sizing: border-box;
    }
    #deltaDisplay {
      font-size: 24px;
      margin-top: 10px;
      text-align: center;
    }
    #startButton {
      padding: 10px 20px;
      font-size: 18px;
      width: 100%;
    }
    #sliders {
      display: flex;
      justify-content: space-around;
      margin-top: 10px;
    }
    .slider-container {
      flex: 1;
      margin: 0 5px;
    }
    .slider-container label {
      display: block;
      text-align: center;
    }
    .slider-container input[type="range"] {
      width: 100%;
    }
    #meters {
      display: flex;
      justify-content: space-around;
      margin-top: 10px;
    }
    .meter-container {
      flex: 1;
      margin: 0 5px;
      text-align: center;
    }
    .meter {
      width: 100%;
      height: 20px;
      background-color: #555;
      position: relative;
      margin-top: 5px;
    }
    .meter-fill {
      height: 100%;
      background-color: lime;
      width: 0%;
    }
    .meter-threshold {
      position: absolute;
      top: -2px;
      width: 2px;
      height: 24px;
      background-color: red;
    }
    #waveformCanvas {
      width: 100%;
      height: 100px;
      background-color: #000;
      display: block;
      margin-top: 10px;
    }
  </style>
</head>
<body>

<div id="videoContainer">
  <video id="videoElement" autoplay playsinline muted></video>
  <canvas id="videoCanvas"></canvas>
  <div id="overlay">
    <div id="crosshair"></div>
  </div>
</div>

<div id="controls">
  <button id="startButton">Start Measurement</button>
  <div id="sliders">
    <div class="slider-container">
      <label for="brightnessThreshold">Brightness Threshold: <span id="brightnessValue">250</span></label>
      <input type="range" id="brightnessThreshold" min="0" max="255" value="250">
    </div>
    <div class="slider-container">
      <label for="volumeThreshold">Volume Threshold: <span id="volumeValue">15</span></label>
      <input type="range" id="volumeThreshold" min="0" max="100" value="15">
    </div>
  </div>
  <div id="meters">
    <div class="meter-container">
      <div>Brightness Level</div>
      <div class="meter" id="brightnessMeter">
        <div class="meter-fill" id="brightnessFill"></div>
        <div class="meter-threshold" id="brightnessMeterThreshold"></div>
      </div>
    </div>
    <div class="meter-container">
      <div>Volume Level</div>
      <div class="meter" id="volumeMeter">
        <div class="meter-fill" id="volumeFill"></div>
        <div class="meter-threshold" id="volumeMeterThreshold"></div>
      </div>
    </div>
  </div>
  <canvas id="waveformCanvas"></canvas>
  <div id="deltaDisplay">Delta: -- ms</div>
</div>

<script>
  let video = document.getElementById('videoElement');
  let canvas = document.getElementById('videoCanvas');
  let deltaDisplay = document.getElementById('deltaDisplay');
  let startButton = document.getElementById('startButton');
  let crosshair = document.getElementById('crosshair');

  let brightnessThresholdInput = document.getElementById('brightnessThreshold');
  let volumeThresholdInput = document.getElementById('volumeThreshold');
  let brightnessValueDisplay = document.getElementById('brightnessValue');
  let volumeValueDisplay = document.getElementById('volumeValue');

  let brightnessMeterFill = document.getElementById('brightnessFill');
  let volumeMeterFill = document.getElementById('volumeFill');
  let brightnessMeterThreshold = document.getElementById('brightnessMeterThreshold');
  let volumeMeterThreshold = document.getElementById('volumeMeterThreshold');

  let waveformCanvas = document.getElementById('waveformCanvas');
  let waveformCtx = waveformCanvas.getContext('2d');

  let videoStream;
  let audioStream;
  let audioContext;
  let analyser;
  let dataArray;

  let lastFlashTime = null;
  let lastBeepTime = null;

  let running = false;

  let brightnessThreshold = parseInt(brightnessThresholdInput.value);
  let volumeThreshold = parseInt(volumeThresholdInput.value);

  let lastBrightnessOverThreshold = false;
  let lastVolumeOverThreshold = false;

  startButton.addEventListener('click', async () => {
    if (!running) {
      startButton.disabled = true;
      await startApp();
      startButton.textContent = 'Stop Measurement';
      startButton.disabled = false;
      running = true;
    } else {
      stopApp();
      startButton.textContent = 'Start Measurement';
      deltaDisplay.textContent = 'Delta: -- ms';
      running = false;
    }
  });

  brightnessThresholdInput.addEventListener('input', () => {
    brightnessThreshold = parseInt(brightnessThresholdInput.value);
    brightnessValueDisplay.textContent = brightnessThreshold;
    updateBrightnessThresholdMeter();
  });

  volumeThresholdInput.addEventListener('input', () => {
    volumeThreshold = parseInt(volumeThresholdInput.value);
    volumeValueDisplay.textContent = volumeThreshold;
    updateVolumeThresholdMeter();
  });

  function updateBrightnessThresholdMeter() {
    let meterWidth = document.getElementById('brightnessMeter').offsetWidth;
    brightnessMeterThreshold.style.left = (brightnessThreshold / 255) * meterWidth - 1 + 'px';
  }

  function updateVolumeThresholdMeter() {
    let meterWidth = document.getElementById('volumeMeter').offsetWidth;
    volumeMeterThreshold.style.left = (volumeThreshold / 100) * meterWidth - 1 + 'px';
  }

  async function startApp() {
    try {
      // Create AudioContext within user interaction
      if (!audioContext) {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        await audioContext.resume();
        console.log(`AudioContext state: ${audioContext.state}`);
      }

      // Get user media with both video and audio
      const stream = await navigator.mediaDevices.getUserMedia({ video: { facingMode: 'environment' }, audio: true });

      // Separate the tracks
      videoStream = new MediaStream(stream.getVideoTracks());
      audioStream = new MediaStream(stream.getAudioTracks());

      // Set up video
      video.srcObject = videoStream;
      video.muted = true; // Mute the video element to prevent audio playback

      // Set up audio processing
      setupAudioProcessing();

      // Wait for video metadata to be loaded
      video.onloadedmetadata = () => {
        processVideoFrame();
      };

      processAudioFrame();
    } catch (err) {
      console.error('Error accessing media devices.', err);
      alert('Error accessing camera or microphone: ' + err.message);
      startButton.textContent = 'Start Measurement';
      startButton.disabled = false;
      running = false;
    }
  }

  function stopApp() {
    // Stop video stream
    if (videoStream) {
      videoStream.getTracks().forEach(track => track.stop());
    }
    // Stop audio stream
    if (audioStream) {
      audioStream.getTracks().forEach(track => track.stop());
    }
    // Stop audio context
    if (audioContext && audioContext.state !== 'closed') {
      audioContext.close();
      audioContext = null;
    }
  }

  function setupAudioProcessing() {
    let source = audioContext.createMediaStreamSource(audioStream);
    analyser = audioContext.createAnalyser();
    analyser.fftSize = 256; // Match the fftSize used in the meter app
    let bufferLength = analyser.frequencyBinCount;
    dataArray = new Uint8Array(bufferLength);
    source.connect(analyser);

    console.log('Audio processing set up');
  }

  function processVideoFrame() {
    if (!running) return;

    let ctx = canvas.getContext('2d');
    if (video.videoWidth === 0 || video.videoHeight === 0) {
      requestAnimationFrame(processVideoFrame);
      return;
    }

    canvas.width = video.videoWidth;
    canvas.height = video.videoHeight;
    ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

    // Get pixel data from center region
    let centerX = canvas.width / 2;
    let centerY = canvas.height / 2;
    let sampleSize = 10;
    let imageData = ctx.getImageData(centerX - sampleSize / 2, centerY - sampleSize / 2, sampleSize, sampleSize);
    let pixels = imageData.data;
    let sum = 0;
    for (let i = 0; i < pixels.length; i += 4) {
      // Grayscale value
      let brightness = (pixels[i] + pixels[i + 1] + pixels[i + 2]) / 3;
      sum += brightness;
    }
    let avgBrightness = sum / (pixels.length / 4);

    // Update brightness meter
    let brightnessPercent = (avgBrightness / 255) * 100;
    brightnessMeterFill.style.width = brightnessPercent + '%';

    // Threshold crossing detection
    let brightnessOverThreshold = avgBrightness > brightnessThreshold;
    if (brightnessOverThreshold && !lastBrightnessOverThreshold) {
      let currentTime = performance.now();
      lastFlashTime = currentTime;
      indicateFlashDetection(); // Visual feedback for flash detection
      calculateDelta();
    }
    lastBrightnessOverThreshold = brightnessOverThreshold;

    requestAnimationFrame(processVideoFrame);
  }

  function processAudioFrame() {
    if (!running) return;
    analyser.getByteFrequencyData(dataArray);

    // Calculate maximum amplitude in frequency domain
    let max = Math.max(...dataArray);

    // Normalize max value to 0 - 1 range
    let normalizedVolume = max / 255;

    // Update volume meter
    let volumePercent = normalizedVolume * 100;
    volumeMeterFill.style.width = volumePercent + '%';

    // Log values for debugging
    console.log(`normalizedVolume: ${normalizedVolume}, volumePercent: ${volumePercent}`);

    // Threshold crossing detection
    let volumeOverThreshold = volumePercent > volumeThreshold;
    if (volumeOverThreshold && !lastVolumeOverThreshold) {
      console.log('Volume threshold crossed');
      let currentTime = performance.now();
      lastBeepTime = currentTime;
      indicateBeepDetection(); // Visual feedback for beep detection
      calculateDelta();
    }
    lastVolumeOverThreshold = volumeOverThreshold;

    // Draw waveform
    drawWaveformFrequency();

    requestAnimationFrame(processAudioFrame);
  }

  function drawWaveformFrequency() {
    // Set canvas dimensions
    waveformCanvas.width = waveformCanvas.offsetWidth;
    waveformCanvas.height = waveformCanvas.offsetHeight;

    // Clear canvas
    waveformCtx.fillStyle = 'rgb(0, 0, 0)';
    waveformCtx.fillRect(0, 0, waveformCanvas.width, waveformCanvas.height);

    // Draw frequency data
    let barWidth = (waveformCanvas.width / dataArray.length) * 2.5;
    let barHeight;
    let x = 0;

    for (let i = 0; i < dataArray.length; i++) {
      barHeight = dataArray[i] / 255 * waveformCanvas.height;

      waveformCtx.fillStyle = 'rgb(' + (barHeight + 50) + ',50,50)';
      waveformCtx.fillRect(x, waveformCanvas.height - barHeight, barWidth, barHeight);

      x += barWidth + 1;
    }
  }

  function calculateDelta() {
    if (lastFlashTime && lastBeepTime) {
      let delta = lastFlashTime - lastBeepTime;
      deltaDisplay.textContent = 'Delta: ' + delta.toFixed(2) + ' ms';
    }
  }

  function indicateFlashDetection() {
    // Change crosshair color to green briefly
    crosshair.style.borderColor = 'lime';
    setTimeout(() => {
      crosshair.style.borderColor = 'red';
    }, 200);
  }

  function indicateBeepDetection() {
    // Change delta display color to yellow briefly
    deltaDisplay.style.color = 'yellow';
    setTimeout(() => {
      deltaDisplay.style.color = '#fff';
    }, 200);
  }

  // Initialize threshold meters
  updateBrightnessThresholdMeter();
  updateVolumeThresholdMeter();

</script>

</body>
</html>